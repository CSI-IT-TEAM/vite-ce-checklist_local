import { i as __toESM, n as __export, t as __commonJS } from "./chunk-mMvWCSj1.js";
import { t as require_react } from "./react-GaupdY8b.js";
import { t as require_jsx_runtime } from "./jsx-runtime-C11-RKVM.js";

//#region node_modules/barcode-detector/dist/es/ponyfill.js
var Ue = (o$1) => {
	throw TypeError(o$1);
};
var Ve = (o$1, l$1, d$1) => l$1.has(o$1) || Ue("Cannot " + d$1);
var We = (o$1, l$1, d$1) => (Ve(o$1, l$1, "read from private field"), d$1 ? d$1.call(o$1) : l$1.get(o$1)), He = (o$1, l$1, d$1) => l$1.has(o$1) ? Ue("Cannot add the same private member more than once") : l$1 instanceof WeakSet ? l$1.add(o$1) : l$1.set(o$1, d$1), ke = (o$1, l$1, d$1, b) => (Ve(o$1, l$1, "write to private field"), b ? b.call(o$1, d$1) : l$1.set(o$1, d$1), d$1);
var Dt = [
	["Aztec", "M"],
	["Codabar", "L"],
	["Code39", "L"],
	["Code93", "L"],
	["Code128", "L"],
	["DataBar", "L"],
	["DataBarExpanded", "L"],
	["DataMatrix", "M"],
	["EAN-8", "L"],
	["EAN-13", "L"],
	["ITF", "L"],
	["MaxiCode", "M"],
	["PDF417", "M"],
	["QRCode", "M"],
	["UPC-A", "L"],
	["UPC-E", "L"],
	["MicroQRCode", "M"],
	["rMQRCode", "M"],
	["DXFilmEdge", "L"],
	["DataBarLimited", "L"]
], Mt = Dt.map(([o$1]) => o$1), Ma = Mt.filter((o$1, l$1) => Dt[l$1][1] === "L"), Aa = Mt.filter((o$1, l$1) => Dt[l$1][1] === "M");
function qt(o$1) {
	switch (o$1) {
		case "Linear-Codes": return Ma.reduce((l$1, d$1) => l$1 | qt(d$1), 0);
		case "Matrix-Codes": return Aa.reduce((l$1, d$1) => l$1 | qt(d$1), 0);
		case "Any": return (1 << Dt.length) - 1;
		case "None": return 0;
		default: return 1 << Mt.indexOf(o$1);
	}
}
function Fa(o$1) {
	if (o$1 === 0) return "None";
	return Mt[31 - Math.clz32(o$1)];
}
function Ra(o$1) {
	return o$1.reduce((l$1, d$1) => l$1 | qt(d$1), 0);
}
var La = [
	"LocalAverage",
	"GlobalHistogram",
	"FixedThreshold",
	"BoolCast"
];
function ja(o$1) {
	return La.indexOf(o$1);
}
var Ne = [
	"Unknown",
	"ASCII",
	"ISO8859_1",
	"ISO8859_2",
	"ISO8859_3",
	"ISO8859_4",
	"ISO8859_5",
	"ISO8859_6",
	"ISO8859_7",
	"ISO8859_8",
	"ISO8859_9",
	"ISO8859_10",
	"ISO8859_11",
	"ISO8859_13",
	"ISO8859_14",
	"ISO8859_15",
	"ISO8859_16",
	"Cp437",
	"Cp1250",
	"Cp1251",
	"Cp1252",
	"Cp1256",
	"Shift_JIS",
	"Big5",
	"GB2312",
	"GB18030",
	"EUC_JP",
	"EUC_KR",
	"UTF16BE",
	"UTF16BE",
	"UTF8",
	"UTF16LE",
	"UTF32BE",
	"UTF32LE",
	"BINARY"
];
function Ba(o$1) {
	return o$1 === "UnicodeBig" ? Ne.indexOf("UTF16BE") : Ne.indexOf(o$1);
}
var Ua = [
	"Text",
	"Binary",
	"Mixed",
	"GS1",
	"ISO15434",
	"UnknownECI"
];
function Va(o$1) {
	return Ua[o$1];
}
var Wa = [
	"Ignore",
	"Read",
	"Require"
];
function Ha(o$1) {
	return Wa.indexOf(o$1);
}
var ka = [
	"Plain",
	"ECI",
	"HRI",
	"Hex",
	"Escaped"
];
function Na(o$1) {
	return ka.indexOf(o$1);
}
var It = {
	formats: [],
	tryHarder: !0,
	tryRotate: !0,
	tryInvert: !0,
	tryDownscale: !0,
	tryDenoise: !1,
	binarizer: "LocalAverage",
	isPure: !1,
	downscaleFactor: 3,
	downscaleThreshold: 500,
	minLineCount: 2,
	maxNumberOfSymbols: 255,
	tryCode39ExtendedMode: !0,
	returnErrors: !1,
	eanAddOnSymbol: "Ignore",
	textMode: "HRI",
	characterSet: "Unknown"
};
function ze(o$1) {
	return {
		...o$1,
		formats: Ra(o$1.formats),
		binarizer: ja(o$1.binarizer),
		eanAddOnSymbol: Ha(o$1.eanAddOnSymbol),
		textMode: Na(o$1.textMode),
		characterSet: Ba(o$1.characterSet)
	};
}
function za(o$1) {
	return {
		...o$1,
		format: Fa(o$1.format),
		contentType: Va(o$1.contentType),
		eccLevel: o$1.ecLevel
	};
}
var yo = "2.2.4", vo = "fba4e9503fee4518ca2e89510baeea9bcc36dc8d", Ga = { locateFile: (o$1, l$1) => {
	const d$1 = o$1.match(/_(.+?)\.wasm$/);
	return d$1 ? `https://fastly.jsdelivr.net/npm/zxing-wasm@2.2.4/dist/${d$1[1]}/${o$1}` : l$1 + o$1;
} }, St = /* @__PURE__ */ new WeakMap();
function Xa(o$1, l$1) {
	return Object.is(o$1, l$1) || Object.keys(o$1).length === Object.keys(l$1).length && Object.keys(o$1).every((d$1) => Object.hasOwn(l$1, d$1) && o$1[d$1] === l$1[d$1]);
}
function Xe(o$1, { overrides: l$1, equalityFn: d$1 = Xa, fireImmediately: b = !1 } = {}) {
	var f$1;
	const [I$1, D$1] = (f$1 = St.get(o$1)) != null ? f$1 : [Ga], M$1 = l$1 != null ? l$1 : I$1;
	let _;
	if (b) {
		if (D$1 && (_ = d$1(I$1, M$1))) return D$1;
		const A = o$1({ ...M$1 });
		return St.set(o$1, [M$1, A]), A;
	}
	(_ != null ? _ : d$1(I$1, M$1)) || St.set(o$1, [M$1]);
}
async function Ya(o$1, l$1, d$1 = It) {
	const b = {
		...It,
		...d$1
	}, f$1 = await Xe(o$1, { fireImmediately: !0 });
	let I$1, D$1;
	if ("width" in l$1 && "height" in l$1 && "data" in l$1) {
		const { data: _, data: { byteLength: A }, width: U, height: G$1 } = l$1;
		D$1 = f$1._malloc(A), f$1.HEAPU8.set(_, D$1), I$1 = f$1.readBarcodesFromPixmap(D$1, U, G$1, ze(b));
	} else {
		let _, A;
		if ("buffer" in l$1) [_, A] = [l$1.byteLength, l$1];
		else if ("byteLength" in l$1) [_, A] = [l$1.byteLength, new Uint8Array(l$1)];
		else if ("size" in l$1) [_, A] = [l$1.size, new Uint8Array(await l$1.arrayBuffer())];
		else throw new TypeError("Invalid input type");
		D$1 = f$1._malloc(_), f$1.HEAPU8.set(A, D$1), I$1 = f$1.readBarcodesFromImage(D$1, _, ze(b));
	}
	f$1._free(D$1);
	const M$1 = [];
	for (let _ = 0; _ < I$1.size(); ++_) M$1.push(za(I$1.get(_)));
	return M$1;
}
({ ...It }), [...It.formats];
async function Zt(o$1 = {}) {
	var l$1, d$1, b, f$1 = o$1, I$1 = !!globalThis.window, D$1 = typeof Bun < "u", M$1 = !!globalThis.WorkerGlobalScope;
	!((d$1 = globalThis.process) === null || d$1 === void 0 || (d$1 = d$1.versions) === null || d$1 === void 0) && d$1.node && ((b = globalThis.process) === null || b === void 0 || b.type);
	var _ = "./this.program", A, U = "";
	function G$1(t$1) {
		return f$1.locateFile ? f$1.locateFile(t$1, U) : U + t$1;
	}
	var tt, X;
	if (I$1 || M$1 || D$1) {
		try {
			U = new URL(".", A).href;
		} catch {}
		M$1 && (X = (t$1) => {
			var e$1 = new XMLHttpRequest();
			return e$1.open("GET", t$1, !1), e$1.responseType = "arraybuffer", e$1.send(null), new Uint8Array(e$1.response);
		}), tt = async (t$1) => {
			var e$1 = await fetch(t$1, { credentials: "same-origin" });
			if (e$1.ok) return e$1.arrayBuffer();
			throw new Error(e$1.status + " : " + e$1.url);
		};
	}
	var nt = console.log.bind(console), V$1 = console.error.bind(console), q$1, ht = !1, Qt, Jt, Y$1, W, dt, at, ot, T$1, Kt, te, ee = !1;
	function re() {
		var t$1 = Pt.buffer;
		Y$1 = new Int8Array(t$1), dt = new Int16Array(t$1), f$1.HEAPU8 = W = new Uint8Array(t$1), at = new Uint16Array(t$1), ot = new Int32Array(t$1), T$1 = new Uint32Array(t$1), Kt = new Float32Array(t$1), te = new Float64Array(t$1);
	}
	function ar() {
		if (f$1.preRun) for (typeof f$1.preRun == "function" && (f$1.preRun = [f$1.preRun]); f$1.preRun.length;) yr(f$1.preRun.shift());
		ne(oe);
	}
	function or() {
		ee = !0, lt.xa();
	}
	function ir() {
		if (f$1.postRun) for (typeof f$1.postRun == "function" && (f$1.postRun = [f$1.postRun]); f$1.postRun.length;) pr(f$1.postRun.shift());
		ne(ae);
	}
	function At(t$1) {
		var e$1, r$1;
		(e$1 = f$1.onAbort) === null || e$1 === void 0 || e$1.call(f$1, t$1), t$1 = "Aborted(" + t$1 + ")", V$1(t$1), ht = !0, t$1 += ". Build with -sASSERTIONS for more info.";
		var n$1 = new WebAssembly.RuntimeError(t$1);
		throw (r$1 = Jt) === null || r$1 === void 0 || r$1(n$1), n$1;
	}
	var pt;
	function sr() {
		return G$1("zxing_reader.wasm");
	}
	function ur(t$1) {
		if (t$1 == pt && q$1) return new Uint8Array(q$1);
		if (X) return X(t$1);
		throw "both async and sync fetching of the wasm failed";
	}
	async function cr(t$1) {
		if (!q$1) try {
			var e$1 = await tt(t$1);
			return new Uint8Array(e$1);
		} catch {}
		return ur(t$1);
	}
	async function lr(t$1, e$1) {
		try {
			var r$1 = await cr(t$1);
			return await WebAssembly.instantiate(r$1, e$1);
		} catch (a$1) {
			V$1(`failed to asynchronously prepare wasm: ${a$1}`), At(a$1);
		}
	}
	async function fr(t$1, e$1, r$1) {
		if (!t$1 && WebAssembly.instantiateStreaming) try {
			var n$1 = fetch(e$1, { credentials: "same-origin" });
			return await WebAssembly.instantiateStreaming(n$1, r$1);
		} catch (i$1) {
			V$1(`wasm streaming compile failed: ${i$1}`), V$1("falling back to ArrayBuffer instantiation");
		}
		return lr(e$1, r$1);
	}
	function hr() {
		return { a: qn };
	}
	async function dr() {
		function t$1(i$1, s$1) {
			return lt = i$1.exports, Xn(lt), re(), lt;
		}
		function e$1(i$1) {
			return t$1(i$1.instance);
		}
		var r$1 = hr();
		if (f$1.instantiateWasm) return new Promise((i$1, s$1) => {
			f$1.instantiateWasm(r$1, (u$1, c$1) => {
				i$1(t$1(u$1));
			});
		});
		pt ??= sr();
		return e$1(await fr(q$1, pt, r$1));
	}
	var ne = (t$1) => {
		for (; t$1.length > 0;) t$1.shift()(f$1);
	}, ae = [], pr = (t$1) => ae.push(t$1), oe = [], yr = (t$1) => oe.push(t$1), m$1 = (t$1) => _e(t$1), g$1 = () => xe(), yt = [], vt = 0, vr = (t$1) => {
		var e$1 = new Ft(t$1);
		return e$1.get_caught() || (e$1.set_caught(!0), vt--), e$1.set_rethrown(!1), yt.push(e$1), Ie(t$1), Pe(t$1);
	}, H = 0, mr = () => {
		v(0, 0);
		var t$1 = yt.pop();
		Se(t$1.excPtr), H = 0;
	};
	class Ft {
		constructor(e$1) {
			this.excPtr = e$1, this.ptr = e$1 - 24;
		}
		set_type(e$1) {
			T$1[this.ptr + 4 >> 2] = e$1;
		}
		get_type() {
			return T$1[this.ptr + 4 >> 2];
		}
		set_destructor(e$1) {
			T$1[this.ptr + 8 >> 2] = e$1;
		}
		get_destructor() {
			return T$1[this.ptr + 8 >> 2];
		}
		set_caught(e$1) {
			e$1 = e$1 ? 1 : 0, Y$1[this.ptr + 12] = e$1;
		}
		get_caught() {
			return Y$1[this.ptr + 12] != 0;
		}
		set_rethrown(e$1) {
			e$1 = e$1 ? 1 : 0, Y$1[this.ptr + 13] = e$1;
		}
		get_rethrown() {
			return Y$1[this.ptr + 13] != 0;
		}
		init(e$1, r$1) {
			this.set_adjusted_ptr(0), this.set_type(e$1), this.set_destructor(r$1);
		}
		set_adjusted_ptr(e$1) {
			T$1[this.ptr + 16 >> 2] = e$1;
		}
		get_adjusted_ptr() {
			return T$1[this.ptr + 16 >> 2];
		}
	}
	var mt = (t$1) => Oe(t$1), Rt = (t$1) => {
		var e$1 = H;
		if (!e$1) return mt(0), 0;
		var r$1 = new Ft(e$1);
		r$1.set_adjusted_ptr(e$1);
		var n$1 = r$1.get_type();
		if (!n$1) return mt(0), e$1;
		for (var a$1 of t$1) {
			if (a$1 === 0 || a$1 === n$1) break;
			var i$1 = r$1.ptr + 16;
			if (De(a$1, n$1, i$1)) return mt(a$1), e$1;
		}
		return mt(n$1), e$1;
	}, gr = () => Rt([]), wr = (t$1) => Rt([t$1]), br = (t$1, e$1) => Rt([t$1, e$1]), $r = () => {
		var t$1 = yt.pop();
		t$1 || At("no exception to throw");
		var e$1 = t$1.excPtr;
		throw t$1.get_rethrown() || (yt.push(t$1), t$1.set_rethrown(!0), t$1.set_caught(!1), vt++), H = e$1, H;
	}, Cr = (t$1, e$1, r$1) => {
		throw new Ft(t$1).init(e$1, r$1), H = t$1, vt++, H;
	}, Tr = () => vt, Er = (t$1) => {
		throw H || (H = t$1), H;
	}, Pr = () => At(""), gt = {}, Lt = (t$1) => {
		for (; t$1.length;) {
			var e$1 = t$1.pop();
			t$1.pop()(e$1);
		}
	};
	function it(t$1) {
		return this.fromWireType(T$1[t$1 >> 2]);
	}
	var et = {}, Z = {}, wt = {}, Or = class extends Error {
		constructor(t$1) {
			super(t$1), this.name = "InternalError";
		}
	}, bt = (t$1) => {
		throw new Or(t$1);
	}, Q$1 = (t$1, e$1, r$1) => {
		t$1.forEach((u$1) => wt[u$1] = e$1);
		function n$1(u$1) {
			var c$1 = r$1(u$1);
			c$1.length !== t$1.length && bt("Mismatched type converter count");
			for (var h$1 = 0; h$1 < t$1.length; ++h$1) j(t$1[h$1], c$1[h$1]);
		}
		var a$1 = new Array(e$1.length), i$1 = [], s$1 = 0;
		{
			const u$1 = e$1;
			for (let c$1 = 0; c$1 < u$1.length; ++c$1) {
				const h$1 = u$1[c$1];
				Z.hasOwnProperty(h$1) ? a$1[c$1] = Z[h$1] : (i$1.push(h$1), et.hasOwnProperty(h$1) || (et[h$1] = []), et[h$1].push(() => {
					a$1[c$1] = Z[h$1], ++s$1, s$1 === i$1.length && n$1(a$1);
				}));
			}
		}
		i$1.length === 0 && n$1(a$1);
	}, _r = (t$1) => {
		var e$1 = gt[t$1];
		delete gt[t$1];
		var r$1 = e$1.rawConstructor, n$1 = e$1.rawDestructor, a$1 = e$1.fields, i$1 = a$1.map((s$1) => s$1.getterReturnType).concat(a$1.map((s$1) => s$1.setterArgumentType));
		Q$1([t$1], i$1, (s$1) => {
			var u$1 = {};
			{
				const c$1 = a$1;
				for (let h$1 = 0; h$1 < c$1.length; ++h$1) {
					const p$1 = c$1[h$1], y$1 = s$1[h$1], C$1 = p$1.getter, P = p$1.getterContext, S = s$1[h$1 + a$1.length], x = p$1.setter, O = p$1.setterContext;
					u$1[p$1.fieldName] = {
						read: (E$1) => y$1.fromWireType(C$1(P, E$1)),
						write: (E$1, K) => {
							var R$1 = [];
							x(O, E$1, S.toWireType(R$1, K)), Lt(R$1);
						},
						optional: y$1.optional
					};
				}
			}
			return [{
				name: e$1.name,
				fromWireType: (c$1) => {
					var h$1 = {};
					for (var p$1 in u$1) h$1[p$1] = u$1[p$1].read(c$1);
					return n$1(c$1), h$1;
				},
				toWireType: (c$1, h$1) => {
					for (var p$1 in u$1) if (!(p$1 in h$1) && !u$1[p$1].optional) throw new TypeError(`Missing field: "${p$1}"`);
					var y$1 = r$1();
					for (p$1 in u$1) u$1[p$1].write(y$1, h$1[p$1]);
					return c$1 !== null && c$1.push(n$1, y$1), y$1;
				},
				readValueFromPointer: it,
				destructorFunction: n$1
			}];
		});
	}, xr = (t$1, e$1, r$1, n$1, a$1) => {}, F$1 = (t$1) => {
		for (var e$1 = "";;) {
			var r$1 = W[t$1++];
			if (!r$1) return e$1;
			e$1 += String.fromCharCode(r$1);
		}
	}, st = class extends Error {
		constructor(t$1) {
			super(t$1), this.name = "BindingError";
		}
	}, $ = (t$1) => {
		throw new st(t$1);
	};
	function Sr(t$1, e$1) {
		let r$1 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
		var n$1 = e$1.name;
		if (t$1 || $(`type "${n$1}" must have a positive integer typeid pointer`), Z.hasOwnProperty(t$1)) {
			if (r$1.ignoreDuplicateRegistrations) return;
			$(`Cannot register type '${n$1}' twice`);
		}
		if (Z[t$1] = e$1, delete wt[t$1], et.hasOwnProperty(t$1)) {
			var a$1 = et[t$1];
			delete et[t$1], a$1.forEach((i$1) => i$1());
		}
	}
	function j(t$1, e$1) {
		return Sr(t$1, e$1, arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {});
	}
	var Ir = (t$1, e$1, r$1, n$1) => {
		e$1 = F$1(e$1), j(t$1, {
			name: e$1,
			fromWireType: function(a$1) {
				return !!a$1;
			},
			toWireType: function(a$1, i$1) {
				return i$1 ? r$1 : n$1;
			},
			readValueFromPointer: function(a$1) {
				return this.fromWireType(W[a$1]);
			},
			destructorFunction: null
		});
	}, Dr = (t$1) => ({
		count: t$1.count,
		deleteScheduled: t$1.deleteScheduled,
		preservePointerOnDelete: t$1.preservePointerOnDelete,
		ptr: t$1.ptr,
		ptrType: t$1.ptrType,
		smartPtr: t$1.smartPtr,
		smartPtrType: t$1.smartPtrType
	}), jt = (t$1) => {
		function e$1(r$1) {
			return r$1.$$.ptrType.registeredClass.name;
		}
		$(e$1(t$1) + " instance already deleted");
	}, Bt = !1, ie = (t$1) => {}, Mr = (t$1) => {
		t$1.smartPtr ? t$1.smartPtrType.rawDestructor(t$1.smartPtr) : t$1.ptrType.registeredClass.rawDestructor(t$1.ptr);
	}, se = (t$1) => {
		t$1.count.value -= 1;
		t$1.count.value === 0 && Mr(t$1);
	}, ut = (t$1) => globalThis.FinalizationRegistry ? (Bt = new FinalizationRegistry((e$1) => {
		se(e$1.$$);
	}), ut = (e$1) => {
		var r$1 = e$1.$$;
		if (!!r$1.smartPtr) {
			var a$1 = { $$: r$1 };
			Bt.register(e$1, a$1, e$1);
		}
		return e$1;
	}, ie = (e$1) => Bt.unregister(e$1), ut(t$1)) : (ut = (e$1) => e$1, t$1), Ar = () => {
		let t$1 = $t.prototype;
		Object.assign(t$1, {
			isAliasOf(r$1) {
				if (!(this instanceof $t) || !(r$1 instanceof $t)) return !1;
				var n$1 = this.$$.ptrType.registeredClass, a$1 = this.$$.ptr;
				r$1.$$ = r$1.$$;
				for (var i$1 = r$1.$$.ptrType.registeredClass, s$1 = r$1.$$.ptr; n$1.baseClass;) a$1 = n$1.upcast(a$1), n$1 = n$1.baseClass;
				for (; i$1.baseClass;) s$1 = i$1.upcast(s$1), i$1 = i$1.baseClass;
				return n$1 === i$1 && a$1 === s$1;
			},
			clone() {
				if (this.$$.ptr || jt(this), this.$$.preservePointerOnDelete) return this.$$.count.value += 1, this;
				var r$1 = ut(Object.create(Object.getPrototypeOf(this), { $$: { value: Dr(this.$$) } }));
				return r$1.$$.count.value += 1, r$1.$$.deleteScheduled = !1, r$1;
			},
			delete() {
				this.$$.ptr || jt(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && $("Object already scheduled for deletion"), ie(this), se(this.$$), this.$$.preservePointerOnDelete || (this.$$.smartPtr = void 0, this.$$.ptr = void 0);
			},
			isDeleted() {
				return !this.$$.ptr;
			},
			deleteLater() {
				return this.$$.ptr || jt(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && $("Object already scheduled for deletion"), this.$$.deleteScheduled = !0, this;
			}
		});
		const e$1 = Symbol.dispose;
		e$1 && (t$1[e$1] = t$1.delete);
	};
	function $t() {}
	var Ut = (t$1, e$1) => Object.defineProperty(e$1, "name", { value: t$1 }), ue = {}, ce = (t$1, e$1, r$1) => {
		if (t$1[e$1].overloadTable === void 0) {
			var n$1 = t$1[e$1];
			t$1[e$1] = function() {
				for (var a$1 = arguments.length, i$1 = new Array(a$1), s$1 = 0; s$1 < a$1; s$1++) i$1[s$1] = arguments[s$1];
				return t$1[e$1].overloadTable.hasOwnProperty(i$1.length) || $(`Function '${r$1}' called with an invalid number of arguments (${i$1.length}) - expects one of (${t$1[e$1].overloadTable})!`), t$1[e$1].overloadTable[i$1.length].apply(this, i$1);
			}, t$1[e$1].overloadTable = [], t$1[e$1].overloadTable[n$1.argCount] = n$1;
		}
	}, le = (t$1, e$1, r$1) => {
		f$1.hasOwnProperty(t$1) ? ((r$1 === void 0 || f$1[t$1].overloadTable !== void 0 && f$1[t$1].overloadTable[r$1] !== void 0) && $(`Cannot register public name '${t$1}' twice`), ce(f$1, t$1, t$1), f$1[t$1].overloadTable.hasOwnProperty(r$1) && $(`Cannot register multiple overloads of a function with the same number of arguments (${r$1})!`), f$1[t$1].overloadTable[r$1] = e$1) : (f$1[t$1] = e$1, f$1[t$1].argCount = r$1);
	}, Fr = 48, Rr = 57, Lr = (t$1) => {
		t$1 = t$1.replace(/[^a-zA-Z0-9_]/g, "$");
		var e$1 = t$1.charCodeAt(0);
		return e$1 >= Fr && e$1 <= Rr ? `_${t$1}` : t$1;
	};
	function jr(t$1, e$1, r$1, n$1, a$1, i$1, s$1, u$1) {
		this.name = t$1, this.constructor = e$1, this.instancePrototype = r$1, this.rawDestructor = n$1, this.baseClass = a$1, this.getActualType = i$1, this.upcast = s$1, this.downcast = u$1, this.pureVirtualFunctions = [];
	}
	var Vt = (t$1, e$1, r$1) => {
		for (; e$1 !== r$1;) e$1.upcast || $(`Expected null or instance of ${r$1.name}, got an instance of ${e$1.name}`), t$1 = e$1.upcast(t$1), e$1 = e$1.baseClass;
		return t$1;
	}, Wt = (t$1) => {
		if (t$1 === null) return "null";
		var e$1 = typeof t$1;
		return e$1 === "object" || e$1 === "array" || e$1 === "function" ? t$1.toString() : "" + t$1;
	};
	function Br(t$1, e$1) {
		if (e$1 === null) return this.isReference && $(`null is not a valid ${this.name}`), 0;
		e$1.$$ || $(`Cannot pass "${Wt(e$1)}" as a ${this.name}`), e$1.$$.ptr || $(`Cannot pass deleted object as a pointer of type ${this.name}`);
		var r$1 = e$1.$$.ptrType.registeredClass;
		return Vt(e$1.$$.ptr, r$1, this.registeredClass);
	}
	function Ur(t$1, e$1) {
		var r$1;
		if (e$1 === null) return this.isReference && $(`null is not a valid ${this.name}`), this.isSmartPointer ? (r$1 = this.rawConstructor(), t$1 !== null && t$1.push(this.rawDestructor, r$1), r$1) : 0;
		(!e$1 || !e$1.$$) && $(`Cannot pass "${Wt(e$1)}" as a ${this.name}`), e$1.$$.ptr || $(`Cannot pass deleted object as a pointer of type ${this.name}`), !this.isConst && e$1.$$.ptrType.isConst && $(`Cannot convert argument of type ${e$1.$$.smartPtrType ? e$1.$$.smartPtrType.name : e$1.$$.ptrType.name} to parameter type ${this.name}`);
		var n$1 = e$1.$$.ptrType.registeredClass;
		if (r$1 = Vt(e$1.$$.ptr, n$1, this.registeredClass), this.isSmartPointer) switch (e$1.$$.smartPtr === void 0 && $("Passing raw pointer to smart pointer is illegal"), this.sharingPolicy) {
			case 0:
				e$1.$$.smartPtrType === this ? r$1 = e$1.$$.smartPtr : $(`Cannot convert argument of type ${e$1.$$.smartPtrType ? e$1.$$.smartPtrType.name : e$1.$$.ptrType.name} to parameter type ${this.name}`);
				break;
			case 1:
				r$1 = e$1.$$.smartPtr;
				break;
			case 2:
				if (e$1.$$.smartPtrType === this) r$1 = e$1.$$.smartPtr;
				else {
					var a$1 = e$1.clone();
					r$1 = this.rawShare(r$1, B$1.toHandle(() => a$1.delete())), t$1 !== null && t$1.push(this.rawDestructor, r$1);
				}
				break;
			default: $("Unsupporting sharing policy");
		}
		return r$1;
	}
	function Vr(t$1, e$1) {
		if (e$1 === null) return this.isReference && $(`null is not a valid ${this.name}`), 0;
		e$1.$$ || $(`Cannot pass "${Wt(e$1)}" as a ${this.name}`), e$1.$$.ptr || $(`Cannot pass deleted object as a pointer of type ${this.name}`), e$1.$$.ptrType.isConst && $(`Cannot convert argument of type ${e$1.$$.ptrType.name} to parameter type ${this.name}`);
		var r$1 = e$1.$$.ptrType.registeredClass;
		return Vt(e$1.$$.ptr, r$1, this.registeredClass);
	}
	var fe = (t$1, e$1, r$1) => {
		if (e$1 === r$1) return t$1;
		if (r$1.baseClass === void 0) return null;
		var n$1 = fe(t$1, e$1, r$1.baseClass);
		return n$1 === null ? null : r$1.downcast(n$1);
	}, Wr = {}, Hr = (t$1, e$1) => {
		for (e$1 === void 0 && $("ptr should not be undefined"); t$1.baseClass;) e$1 = t$1.upcast(e$1), t$1 = t$1.baseClass;
		return e$1;
	}, kr = (t$1, e$1) => (e$1 = Hr(t$1, e$1), Wr[e$1]), Ct = (t$1, e$1) => {
		(!e$1.ptrType || !e$1.ptr) && bt("makeClassHandle requires ptr and ptrType");
		return !!e$1.smartPtrType !== !!e$1.smartPtr && bt("Both smartPtrType and smartPtr must be specified"), e$1.count = { value: 1 }, ut(Object.create(t$1, { $$: {
			value: e$1,
			writable: !0
		} }));
	};
	function Nr(t$1) {
		var e$1 = this.getPointee(t$1);
		if (!e$1) return this.destructor(t$1), null;
		var r$1 = kr(this.registeredClass, e$1);
		if (r$1 !== void 0) {
			if (r$1.$$.count.value === 0) return r$1.$$.ptr = e$1, r$1.$$.smartPtr = t$1, r$1.clone();
			var n$1 = r$1.clone();
			return this.destructor(t$1), n$1;
		}
		function a$1() {
			return this.isSmartPointer ? Ct(this.registeredClass.instancePrototype, {
				ptrType: this.pointeeType,
				ptr: e$1,
				smartPtrType: this,
				smartPtr: t$1
			}) : Ct(this.registeredClass.instancePrototype, {
				ptrType: this,
				ptr: t$1
			});
		}
		var s$1 = ue[this.registeredClass.getActualType(e$1)];
		if (!s$1) return a$1.call(this);
		var u$1;
		this.isConst ? u$1 = s$1.constPointerType : u$1 = s$1.pointerType;
		var c$1 = fe(e$1, this.registeredClass, u$1.registeredClass);
		return c$1 === null ? a$1.call(this) : this.isSmartPointer ? Ct(u$1.registeredClass.instancePrototype, {
			ptrType: u$1,
			ptr: c$1,
			smartPtrType: this,
			smartPtr: t$1
		}) : Ct(u$1.registeredClass.instancePrototype, {
			ptrType: u$1,
			ptr: c$1
		});
	}
	var zr = () => {
		Object.assign(Tt.prototype, {
			getPointee(t$1) {
				return this.rawGetPointee && (t$1 = this.rawGetPointee(t$1)), t$1;
			},
			destructor(t$1) {
				var e$1;
				(e$1 = this.rawDestructor) === null || e$1 === void 0 || e$1.call(this, t$1);
			},
			readValueFromPointer: it,
			fromWireType: Nr
		});
	};
	function Tt(t$1, e$1, r$1, n$1, a$1, i$1, s$1, u$1, c$1, h$1, p$1) {
		this.name = t$1, this.registeredClass = e$1, this.isReference = r$1, this.isConst = n$1, this.isSmartPointer = a$1, this.pointeeType = i$1, this.sharingPolicy = s$1, this.rawGetPointee = u$1, this.rawConstructor = c$1, this.rawShare = h$1, this.rawDestructor = p$1, !a$1 && e$1.baseClass === void 0 ? n$1 ? (this.toWireType = Br, this.destructorFunction = null) : (this.toWireType = Vr, this.destructorFunction = null) : this.toWireType = Ur;
	}
	var he = (t$1, e$1, r$1) => {
		f$1.hasOwnProperty(t$1) || bt("Replacing nonexistent public symbol"), f$1[t$1].overloadTable !== void 0 && r$1 !== void 0 ? f$1[t$1].overloadTable[r$1] = e$1 : (f$1[t$1] = e$1, f$1[t$1].argCount = r$1);
	}, N$1 = {}, Gr = (t$1, e$1, r$1) => {
		t$1 = t$1.replace(/p/g, "i");
		var n$1 = N$1[t$1];
		return n$1(e$1, ...r$1);
	}, de = [], w$1 = (t$1) => {
		var e$1 = de[t$1];
		return e$1 || (de[t$1] = e$1 = Fe.get(t$1)), e$1;
	}, Xr = function(t$1, e$1) {
		let r$1 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
		if (t$1.includes("j")) return Gr(t$1, e$1, r$1);
		return w$1(e$1)(...r$1);
	}, qr = function(t$1, e$1) {
		let r$1 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
		return function() {
			for (var n$1 = arguments.length, a$1 = new Array(n$1), i$1 = 0; i$1 < n$1; i$1++) a$1[i$1] = arguments[i$1];
			return Xr(t$1, e$1, a$1, r$1);
		};
	}, L = function(t$1, e$1) {
		t$1 = F$1(t$1);
		function r$1() {
			if (t$1.includes("j")) return qr(t$1, e$1);
			return w$1(e$1);
		}
		var n$1 = r$1();
		return typeof n$1 != "function" && $(`unknown function pointer with signature ${t$1}: ${e$1}`), n$1;
	};
	class Yr extends Error {}
	var pe = (t$1) => {
		var e$1 = Ee(t$1), r$1 = F$1(e$1);
		return z(e$1), r$1;
	}, Et = (t$1, e$1) => {
		var r$1 = [], n$1 = {};
		function a$1(i$1) {
			if (!n$1[i$1] && !Z[i$1]) {
				if (wt[i$1]) {
					wt[i$1].forEach(a$1);
					return;
				}
				r$1.push(i$1), n$1[i$1] = !0;
			}
		}
		throw e$1.forEach(a$1), new Yr(`${t$1}: ` + r$1.map(pe).join([", "]));
	}, Zr = (t$1, e$1, r$1, n$1, a$1, i$1, s$1, u$1, c$1, h$1, p$1, y$1, C$1) => {
		p$1 = F$1(p$1), i$1 = L(a$1, i$1), u$1 && (u$1 = L(s$1, u$1)), h$1 && (h$1 = L(c$1, h$1)), C$1 = L(y$1, C$1);
		var P = Lr(p$1);
		le(P, function() {
			Et(`Cannot construct ${p$1} due to unbound types`, [n$1]);
		}), Q$1([
			t$1,
			e$1,
			r$1
		], n$1 ? [n$1] : [], (S) => {
			S = S[0];
			var x, O;
			n$1 ? (x = S.registeredClass, O = x.instancePrototype) : O = $t.prototype;
			var E$1 = Ut(p$1, function() {
				if (Object.getPrototypeOf(this) !== K) throw new st(`Use 'new' to construct ${p$1}`);
				if (R$1.constructor_body === void 0) throw new st(`${p$1} has no accessible constructor`);
				for (var je = arguments.length, _t = new Array(je), xt = 0; xt < je; xt++) _t[xt] = arguments[xt];
				var Be = R$1.constructor_body[_t.length];
				if (Be === void 0) throw new st(`Tried to invoke ctor of ${p$1} with invalid number of parameters (${_t.length}) - expected (${Object.keys(R$1.constructor_body).toString()}) parameters instead!`);
				return Be.apply(this, _t);
			}), K = Object.create(O, { constructor: { value: E$1 } });
			E$1.prototype = K;
			var R$1 = new jr(p$1, E$1, K, C$1, x, i$1, u$1, h$1);
			if (R$1.baseClass) {
				var k$1, Ot;
				(Ot = (k$1 = R$1.baseClass).__derivedClasses) !== null && Ot !== void 0 || (k$1.__derivedClasses = []), R$1.baseClass.__derivedClasses.push(R$1);
			}
			var Da = new Tt(p$1, R$1, !0, !1, !1), Re = new Tt(p$1 + "*", R$1, !1, !1, !1), Le = new Tt(p$1 + " const*", R$1, !1, !0, !1);
			return ue[t$1] = {
				pointerType: Re,
				constPointerType: Le
			}, he(P, E$1), [
				Da,
				Re,
				Le
			];
		});
	}, Ht = (t$1, e$1) => {
		for (var r$1 = [], n$1 = 0; n$1 < t$1; n$1++) r$1.push(T$1[e$1 + n$1 * 4 >> 2]);
		return r$1;
	};
	function Qr(t$1) {
		for (var e$1 = 1; e$1 < t$1.length; ++e$1) if (t$1[e$1] !== null && t$1[e$1].destructorFunction === void 0) return !0;
		return !1;
	}
	function kt(t$1, e$1, r$1, n$1, a$1, i$1) {
		var s$1 = e$1.length;
		s$1 < 2 && $("argTypes array size mismatch! Must at least get return value and 'this' types!");
		var u$1 = e$1[1] !== null && r$1 !== null, c$1 = Qr(e$1), h$1 = !e$1[0].isVoid, p$1 = s$1 - 2, y$1 = new Array(p$1), C$1 = [], P = [], S = function() {
			P.length = 0;
			var x;
			C$1.length = u$1 ? 2 : 1, C$1[0] = a$1, u$1 && (x = e$1[1].toWireType(P, this), C$1[1] = x);
			for (var O = 0; O < p$1; ++O) y$1[O] = e$1[O + 2].toWireType(P, O < 0 || arguments.length <= O ? void 0 : arguments[O]), C$1.push(y$1[O]);
			var E$1 = n$1(...C$1);
			function K(R$1) {
				if (c$1) Lt(P);
				else for (var k$1 = u$1 ? 1 : 2; k$1 < e$1.length; k$1++) {
					var Ot = k$1 === 1 ? x : y$1[k$1 - 2];
					e$1[k$1].destructorFunction !== null && e$1[k$1].destructorFunction(Ot);
				}
				if (h$1) return e$1[0].fromWireType(R$1);
			}
			return K(E$1);
		};
		return Ut(t$1, S);
	}
	var Jr = (t$1, e$1, r$1, n$1, a$1, i$1) => {
		var s$1 = Ht(e$1, r$1);
		a$1 = L(n$1, a$1), Q$1([], [t$1], (u$1) => {
			u$1 = u$1[0];
			var c$1 = `constructor ${u$1.name}`;
			if (u$1.registeredClass.constructor_body === void 0 && (u$1.registeredClass.constructor_body = []), u$1.registeredClass.constructor_body[e$1 - 1] !== void 0) throw new st(`Cannot register multiple constructors with identical number of parameters (${e$1 - 1}) for class '${u$1.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);
			return u$1.registeredClass.constructor_body[e$1 - 1] = () => {
				Et(`Cannot construct ${u$1.name} due to unbound types`, s$1);
			}, Q$1([], s$1, (h$1) => (h$1.splice(1, 0, null), u$1.registeredClass.constructor_body[e$1 - 1] = kt(c$1, h$1, null, a$1, i$1), [])), [];
		});
	}, ye = (t$1) => {
		t$1 = t$1.trim();
		const e$1 = t$1.indexOf("(");
		return e$1 === -1 ? t$1 : t$1.slice(0, e$1);
	}, Kr = (t$1, e$1, r$1, n$1, a$1, i$1, s$1, u$1, c$1, h$1) => {
		var p$1 = Ht(r$1, n$1);
		e$1 = F$1(e$1), e$1 = ye(e$1), i$1 = L(a$1, i$1), Q$1([], [t$1], (y$1) => {
			y$1 = y$1[0];
			var C$1 = `${y$1.name}.${e$1}`;
			e$1.startsWith("@@") && (e$1 = Symbol[e$1.substring(2)]), u$1 && y$1.registeredClass.pureVirtualFunctions.push(e$1);
			function P() {
				Et(`Cannot call ${C$1} due to unbound types`, p$1);
			}
			var S = y$1.registeredClass.instancePrototype, x = S[e$1];
			return x === void 0 || x.overloadTable === void 0 && x.className !== y$1.name && x.argCount === r$1 - 2 ? (P.argCount = r$1 - 2, P.className = y$1.name, S[e$1] = P) : (ce(S, e$1, C$1), S[e$1].overloadTable[r$1 - 2] = P), Q$1([], p$1, (O) => {
				var E$1 = kt(C$1, O, y$1, i$1, s$1);
				return S[e$1].overloadTable === void 0 ? (E$1.argCount = r$1 - 2, S[e$1] = E$1) : S[e$1].overloadTable[r$1 - 2] = E$1, [];
			}), [];
		});
	}, ve = [], J = [
		0,
		1,
		,
		1,
		null,
		1,
		!0,
		1,
		!1,
		1
	], Nt = (t$1) => {
		t$1 > 9 && --J[t$1 + 1] === 0 && (J[t$1] = void 0, ve.push(t$1));
	}, B$1 = {
		toValue: (t$1) => (t$1 || $(`Cannot use deleted val. handle = ${t$1}`), J[t$1]),
		toHandle: (t$1) => {
			switch (t$1) {
				case void 0: return 2;
				case null: return 4;
				case !0: return 6;
				case !1: return 8;
				default: {
					const e$1 = ve.pop() || J.length;
					return J[e$1] = t$1, J[e$1 + 1] = 1, e$1;
				}
			}
		}
	}, me = {
		name: "emscripten::val",
		fromWireType: (t$1) => {
			var e$1 = B$1.toValue(t$1);
			return Nt(t$1), e$1;
		},
		toWireType: (t$1, e$1) => B$1.toHandle(e$1),
		readValueFromPointer: it,
		destructorFunction: null
	}, tn = (t$1) => j(t$1, me), en = (t$1, e$1) => {
		switch (e$1) {
			case 4: return function(r$1) {
				return this.fromWireType(Kt[r$1 >> 2]);
			};
			case 8: return function(r$1) {
				return this.fromWireType(te[r$1 >> 3]);
			};
			default: throw new TypeError(`invalid float width (${e$1}): ${t$1}`);
		}
	}, rn = (t$1, e$1, r$1) => {
		e$1 = F$1(e$1), j(t$1, {
			name: e$1,
			fromWireType: (n$1) => n$1,
			toWireType: (n$1, a$1) => a$1,
			readValueFromPointer: en(e$1, r$1),
			destructorFunction: null
		});
	}, nn = (t$1, e$1, r$1, n$1, a$1, i$1, s$1, u$1) => {
		var c$1 = Ht(e$1, r$1);
		t$1 = F$1(t$1), t$1 = ye(t$1), a$1 = L(n$1, a$1), le(t$1, function() {
			Et(`Cannot call ${t$1} due to unbound types`, c$1);
		}, e$1 - 1), Q$1([], c$1, (h$1) => {
			var p$1 = [h$1[0], null].concat(h$1.slice(1));
			return he(t$1, kt(t$1, p$1, null, a$1, i$1), e$1 - 1), [];
		});
	}, an = (t$1, e$1, r$1) => {
		switch (e$1) {
			case 1: return r$1 ? (n$1) => Y$1[n$1] : (n$1) => W[n$1];
			case 2: return r$1 ? (n$1) => dt[n$1 >> 1] : (n$1) => at[n$1 >> 1];
			case 4: return r$1 ? (n$1) => ot[n$1 >> 2] : (n$1) => T$1[n$1 >> 2];
			default: throw new TypeError(`invalid integer width (${e$1}): ${t$1}`);
		}
	}, on = (t$1, e$1, r$1, n$1, a$1) => {
		e$1 = F$1(e$1);
		const i$1 = n$1 === 0;
		let s$1 = (c$1) => c$1;
		if (i$1) {
			var u$1 = 32 - 8 * r$1;
			s$1 = (c$1) => c$1 << u$1 >>> u$1, a$1 = s$1(a$1);
		}
		j(t$1, {
			name: e$1,
			fromWireType: s$1,
			toWireType: (c$1, h$1) => h$1,
			readValueFromPointer: an(e$1, r$1, n$1 !== 0),
			destructorFunction: null
		});
	}, sn = (t$1, e$1, r$1) => {
		var a$1 = [
			Int8Array,
			Uint8Array,
			Int16Array,
			Uint16Array,
			Int32Array,
			Uint32Array,
			Float32Array,
			Float64Array
		][e$1];
		function i$1(s$1) {
			var u$1 = T$1[s$1 >> 2], c$1 = T$1[s$1 + 4 >> 2];
			return new a$1(Y$1.buffer, c$1, u$1);
		}
		r$1 = F$1(r$1), j(t$1, {
			name: r$1,
			fromWireType: i$1,
			readValueFromPointer: i$1
		}, { ignoreDuplicateRegistrations: !0 });
	}, un = Object.assign({ optional: !0 }, me), cn = (t$1, e$1) => {
		j(t$1, un);
	}, ln = (t$1, e$1, r$1, n$1) => {
		if (!(n$1 > 0)) return 0;
		for (var a$1 = r$1, i$1 = r$1 + n$1 - 1, s$1 = 0; s$1 < t$1.length; ++s$1) {
			var u$1 = t$1.codePointAt(s$1);
			if (u$1 <= 127) {
				if (r$1 >= i$1) break;
				e$1[r$1++] = u$1;
			} else if (u$1 <= 2047) {
				if (r$1 + 1 >= i$1) break;
				e$1[r$1++] = 192 | u$1 >> 6, e$1[r$1++] = 128 | u$1 & 63;
			} else if (u$1 <= 65535) {
				if (r$1 + 2 >= i$1) break;
				e$1[r$1++] = 224 | u$1 >> 12, e$1[r$1++] = 128 | u$1 >> 6 & 63, e$1[r$1++] = 128 | u$1 & 63;
			} else {
				if (r$1 + 3 >= i$1) break;
				e$1[r$1++] = 240 | u$1 >> 18, e$1[r$1++] = 128 | u$1 >> 12 & 63, e$1[r$1++] = 128 | u$1 >> 6 & 63, e$1[r$1++] = 128 | u$1 & 63, s$1++;
			}
		}
		return e$1[r$1] = 0, r$1 - a$1;
	}, rt = (t$1, e$1, r$1) => ln(t$1, W, e$1, r$1), ge = (t$1) => {
		for (var e$1 = 0, r$1 = 0; r$1 < t$1.length; ++r$1) {
			var n$1 = t$1.charCodeAt(r$1);
			n$1 <= 127 ? e$1++ : n$1 <= 2047 ? e$1 += 2 : n$1 >= 55296 && n$1 <= 57343 ? (e$1 += 4, ++r$1) : e$1 += 3;
		}
		return e$1;
	}, we = globalThis.TextDecoder && new TextDecoder(), be = (t$1, e$1, r$1, n$1) => {
		var a$1 = e$1 + r$1;
		if (n$1) return a$1;
		for (; t$1[e$1] && !(e$1 >= a$1);) ++e$1;
		return e$1;
	}, $e = function(t$1) {
		let e$1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, r$1 = arguments.length > 2 ? arguments[2] : void 0, n$1 = arguments.length > 3 ? arguments[3] : void 0;
		var a$1 = be(t$1, e$1, r$1, n$1);
		if (a$1 - e$1 > 16 && t$1.buffer && we) return we.decode(t$1.subarray(e$1, a$1));
		for (var i$1 = ""; e$1 < a$1;) {
			var s$1 = t$1[e$1++];
			if (!(s$1 & 128)) {
				i$1 += String.fromCharCode(s$1);
				continue;
			}
			var u$1 = t$1[e$1++] & 63;
			if ((s$1 & 224) == 192) {
				i$1 += String.fromCharCode((s$1 & 31) << 6 | u$1);
				continue;
			}
			var c$1 = t$1[e$1++] & 63;
			if ((s$1 & 240) == 224 ? s$1 = (s$1 & 15) << 12 | u$1 << 6 | c$1 : s$1 = (s$1 & 7) << 18 | u$1 << 12 | c$1 << 6 | t$1[e$1++] & 63, s$1 < 65536) i$1 += String.fromCharCode(s$1);
			else {
				var h$1 = s$1 - 65536;
				i$1 += String.fromCharCode(55296 | h$1 >> 10, 56320 | h$1 & 1023);
			}
		}
		return i$1;
	}, fn = (t$1, e$1, r$1) => t$1 ? $e(W, t$1, e$1, r$1) : "", hn = (t$1, e$1) => {
		e$1 = F$1(e$1), j(t$1, {
			name: e$1,
			fromWireType(r$1) {
				var n$1 = T$1[r$1 >> 2], a$1 = r$1 + 4, i$1;
				return i$1 = fn(a$1, n$1, !0), z(r$1), i$1;
			},
			toWireType(r$1, n$1) {
				n$1 instanceof ArrayBuffer && (n$1 = new Uint8Array(n$1));
				var a$1, i$1 = typeof n$1 == "string";
				i$1 || ArrayBuffer.isView(n$1) && n$1.BYTES_PER_ELEMENT == 1 || $("Cannot pass non-string to std::string"), i$1 ? a$1 = ge(n$1) : a$1 = n$1.length;
				var s$1 = Xt(4 + a$1 + 1), u$1 = s$1 + 4;
				return T$1[s$1 >> 2] = a$1, i$1 ? rt(n$1, u$1, a$1 + 1) : W.set(n$1, u$1), r$1 !== null && r$1.push(z, s$1), s$1;
			},
			readValueFromPointer: it,
			destructorFunction(r$1) {
				z(r$1);
			}
		});
	}, Ce = globalThis.TextDecoder ? new TextDecoder("utf-16le") : void 0, dn = (t$1, e$1, r$1) => {
		var n$1 = t$1 >> 1, a$1 = be(at, n$1, e$1 / 2, r$1);
		if (a$1 - n$1 > 16 && Ce) return Ce.decode(at.subarray(n$1, a$1));
		for (var i$1 = "", s$1 = n$1; s$1 < a$1; ++s$1) {
			var u$1 = at[s$1];
			i$1 += String.fromCharCode(u$1);
		}
		return i$1;
	}, pn = (t$1, e$1, r$1) => {
		if (r$1 ??= 2147483647, r$1 < 2) return 0;
		r$1 -= 2;
		for (var n$1 = e$1, a$1 = r$1 < t$1.length * 2 ? r$1 / 2 : t$1.length, i$1 = 0; i$1 < a$1; ++i$1) {
			var s$1 = t$1.charCodeAt(i$1);
			dt[e$1 >> 1] = s$1, e$1 += 2;
		}
		return dt[e$1 >> 1] = 0, e$1 - n$1;
	}, yn = (t$1) => t$1.length * 2, vn = (t$1, e$1, r$1) => {
		for (var n$1 = "", a$1 = t$1 >> 2, i$1 = 0; !(i$1 >= e$1 / 4); i$1++) {
			var s$1 = T$1[a$1 + i$1];
			if (!s$1 && !r$1) break;
			n$1 += String.fromCodePoint(s$1);
		}
		return n$1;
	}, mn = (t$1, e$1, r$1) => {
		if (r$1 ??= 2147483647, r$1 < 4) return 0;
		for (var n$1 = e$1, a$1 = n$1 + r$1 - 4, i$1 = 0; i$1 < t$1.length; ++i$1) {
			var s$1 = t$1.codePointAt(i$1);
			if (s$1 > 65535 && i$1++, ot[e$1 >> 2] = s$1, e$1 += 4, e$1 + 4 > a$1) break;
		}
		return ot[e$1 >> 2] = 0, e$1 - n$1;
	}, gn = (t$1) => {
		for (var e$1 = 0, r$1 = 0; r$1 < t$1.length; ++r$1) t$1.codePointAt(r$1) > 65535 && r$1++, e$1 += 4;
		return e$1;
	}, wn = (t$1, e$1, r$1) => {
		r$1 = F$1(r$1);
		var n$1, a$1, i$1;
		e$1 === 2 ? (n$1 = dn, a$1 = pn, i$1 = yn) : (n$1 = vn, a$1 = mn, i$1 = gn), j(t$1, {
			name: r$1,
			fromWireType: (s$1) => {
				var u$1 = T$1[s$1 >> 2], c$1 = n$1(s$1 + 4, u$1 * e$1, !0);
				return z(s$1), c$1;
			},
			toWireType: (s$1, u$1) => {
				typeof u$1 != "string" && $(`Cannot pass non-string to C++ string type ${r$1}`);
				var c$1 = i$1(u$1), h$1 = Xt(4 + c$1 + e$1);
				return T$1[h$1 >> 2] = c$1 / e$1, a$1(u$1, h$1 + 4, c$1 + e$1), s$1 !== null && s$1.push(z, h$1), h$1;
			},
			readValueFromPointer: it,
			destructorFunction(s$1) {
				z(s$1);
			}
		});
	}, bn = (t$1, e$1, r$1, n$1, a$1, i$1) => {
		gt[t$1] = {
			name: F$1(e$1),
			rawConstructor: L(r$1, n$1),
			rawDestructor: L(a$1, i$1),
			fields: []
		};
	}, $n = (t$1, e$1, r$1, n$1, a$1, i$1, s$1, u$1, c$1, h$1) => {
		gt[t$1].fields.push({
			fieldName: F$1(e$1),
			getterReturnType: r$1,
			getter: L(n$1, a$1),
			getterContext: i$1,
			setterArgumentType: s$1,
			setter: L(u$1, c$1),
			setterContext: h$1
		});
	}, Cn = (t$1, e$1) => {
		e$1 = F$1(e$1), j(t$1, {
			isVoid: !0,
			name: e$1,
			fromWireType: () => {},
			toWireType: (r$1, n$1) => {}
		});
	}, zt = [], Tn = (t$1) => {
		var e$1 = zt.length;
		return zt.push(t$1), e$1;
	}, En = (t$1, e$1) => {
		var r$1 = Z[t$1];
		return r$1 === void 0 && $(`${e$1} has unknown type ${pe(t$1)}`), r$1;
	}, Pn = (t$1, e$1) => {
		for (var r$1 = new Array(t$1), n$1 = 0; n$1 < t$1; ++n$1) r$1[n$1] = En(T$1[e$1 + n$1 * 4 >> 2], `parameter ${n$1}`);
		return r$1;
	}, On = (t$1, e$1, r$1) => {
		var n$1 = [], a$1 = t$1(n$1, r$1);
		return n$1.length && (T$1[e$1 >> 2] = B$1.toHandle(n$1)), a$1;
	}, _n = {}, Te = (t$1) => {
		var e$1 = _n[t$1];
		return e$1 === void 0 ? F$1(t$1) : e$1;
	}, xn = (t$1, e$1, r$1) => {
		var n$1 = 8, [a$1, ...i$1] = Pn(t$1, e$1), s$1 = a$1.toWireType.bind(a$1), u$1 = i$1.map((y$1) => y$1.readValueFromPointer.bind(y$1));
		t$1--;
		var c$1 = new Array(t$1), h$1 = (y$1, C$1, P, S) => {
			for (var x = 0, O = 0; O < t$1; ++O) c$1[O] = u$1[O](S + x), x += n$1;
			var E$1;
			switch (r$1) {
				case 0:
					E$1 = B$1.toValue(y$1).apply(null, c$1);
					break;
				case 2:
					E$1 = Reflect.construct(B$1.toValue(y$1), c$1);
					break;
				case 3:
					E$1 = c$1[0];
					break;
				case 1:
					E$1 = B$1.toValue(y$1)[Te(C$1)](...c$1);
					break;
			}
			return On(s$1, P, E$1);
		};
		return Tn(Ut(`methodCaller<(${i$1.map((y$1) => y$1.name)}) => ${a$1.name}>`, h$1));
	}, Sn = (t$1) => t$1 ? (t$1 = Te(t$1), B$1.toHandle(globalThis[t$1])) : B$1.toHandle(globalThis), In = (t$1) => {
		t$1 > 9 && (J[t$1 + 1] += 1);
	}, Dn = (t$1, e$1, r$1, n$1, a$1) => zt[t$1](e$1, r$1, n$1, a$1), Mn = (t$1) => {
		Lt(B$1.toValue(t$1)), Nt(t$1);
	}, An = (t$1, e$1, r$1, n$1) => {
		var a$1 = (/* @__PURE__ */ new Date()).getFullYear(), i$1 = new Date(a$1, 0, 1), s$1 = new Date(a$1, 6, 1), u$1 = i$1.getTimezoneOffset(), c$1 = s$1.getTimezoneOffset(), h$1 = Math.max(u$1, c$1);
		T$1[t$1 >> 2] = h$1 * 60, ot[e$1 >> 2] = +(u$1 != c$1);
		var p$1 = (P) => {
			var S = P >= 0 ? "-" : "+", x = Math.abs(P);
			return `UTC${S}${String(Math.floor(x / 60)).padStart(2, "0")}${String(x % 60).padStart(2, "0")}`;
		}, y$1 = p$1(u$1), C$1 = p$1(c$1);
		c$1 < u$1 ? (rt(y$1, r$1, 17), rt(C$1, n$1, 17)) : (rt(y$1, n$1, 17), rt(C$1, r$1, 17));
	}, Fn = () => 2147483648, Rn = (t$1, e$1) => Math.ceil(t$1 / e$1) * e$1, Ln = (t$1) => {
		var r$1 = (t$1 - Pt.buffer.byteLength + 65535) / 65536 | 0;
		try {
			return Pt.grow(r$1), re(), 1;
		} catch {}
	}, jn = (t$1) => {
		var e$1 = W.length;
		t$1 >>>= 0;
		var r$1 = Fn();
		if (t$1 > r$1) return !1;
		for (var n$1 = 1; n$1 <= 4; n$1 *= 2) {
			var a$1 = e$1 * (1 + .2 / n$1);
			a$1 = Math.min(a$1, t$1 + 100663296);
			if (Ln(Math.min(r$1, Rn(Math.max(t$1, a$1), 65536)))) return !0;
		}
		return !1;
	}, Gt = {}, Bn = () => _ || "./this.program", ct = () => {
		if (!ct.strings) {
			var e$1 = {
				USER: "web_user",
				LOGNAME: "web_user",
				PATH: "/",
				PWD: "/",
				HOME: "/home/web_user",
				LANG: (typeof navigator == "object" && navigator.language || "C").replace("-", "_") + ".UTF-8",
				_: Bn()
			};
			for (var r$1 in Gt) Gt[r$1] === void 0 ? delete e$1[r$1] : e$1[r$1] = Gt[r$1];
			var n$1 = [];
			for (var r$1 in e$1) n$1.push(`${r$1}=${e$1[r$1]}`);
			ct.strings = n$1;
		}
		return ct.strings;
	}, Un = (t$1, e$1) => {
		var r$1 = 0, n$1 = 0;
		for (var a$1 of ct()) {
			var i$1 = e$1 + r$1;
			T$1[t$1 + n$1 >> 2] = i$1, r$1 += rt(a$1, i$1, Infinity) + 1, n$1 += 4;
		}
		return 0;
	}, Vn = (t$1, e$1) => {
		var r$1 = ct();
		T$1[t$1 >> 2] = r$1.length;
		var n$1 = 0;
		for (var a$1 of r$1) n$1 += ge(a$1) + 1;
		return T$1[e$1 >> 2] = n$1, 0;
	}, Wn = (t$1) => 52;
	function Hn(t$1, e$1, r$1, n$1, a$1) {
		return 70;
	}
	var kn = [
		null,
		[],
		[]
	], Nn = (t$1, e$1) => {
		var r$1 = kn[t$1];
		e$1 === 0 || e$1 === 10 ? ((t$1 === 1 ? nt : V$1)($e(r$1)), r$1.length = 0) : r$1.push(e$1);
	}, zn = (t$1, e$1, r$1, n$1) => {
		for (var a$1 = 0, i$1 = 0; i$1 < r$1; i$1++) {
			var s$1 = T$1[e$1 >> 2], u$1 = T$1[e$1 + 4 >> 2];
			e$1 += 8;
			for (var c$1 = 0; c$1 < u$1; c$1++) Nn(t$1, W[s$1 + c$1]);
			a$1 += u$1;
		}
		return T$1[n$1 >> 2] = a$1, 0;
	}, Gn = (t$1) => t$1;
	if (Ar(), zr(), f$1.noExitRuntime && f$1.noExitRuntime, f$1.print && (nt = f$1.print), f$1.printErr && (V$1 = f$1.printErr), f$1.wasmBinary && (q$1 = f$1.wasmBinary), f$1.arguments && f$1.arguments, f$1.thisProgram && (_ = f$1.thisProgram), f$1.preInit) for (typeof f$1.preInit == "function" && (f$1.preInit = [f$1.preInit]); f$1.preInit.length > 0;) f$1.preInit.shift()();
	var Ee, z, Xt, Pe, v, Oe, _e, xe, Se, Ie, De, Me, Ae, Pt, Fe;
	function Xn(t$1) {
		Ee = t$1.ya, z = f$1._free = t$1.za, Xt = f$1._malloc = t$1.Ba, Pe = t$1.Ca, v = t$1.Da, Oe = t$1.Ea, _e = t$1.Fa, xe = t$1.Ga, Se = t$1.Ha, Ie = t$1.Ia, De = t$1.Ja, N$1.viijii = t$1.Ka, Me = N$1.iiijj = t$1.La, N$1.jiji = t$1.Ma, Ae = N$1.jiiii = t$1.Na, N$1.iiiiij = t$1.Oa, N$1.iiiiijj = t$1.Pa, N$1.iiiiiijj = t$1.Qa, Pt = t$1.wa, Fe = t$1.Aa;
	}
	var qn = {
		s: vr,
		w: mr,
		a: gr,
		j: wr,
		m: br,
		Q: $r,
		p: Cr,
		U: Tr,
		d: Er,
		ca: Pr,
		ta: _r,
		ba: xr,
		oa: Ir,
		ra: Zr,
		qa: Jr,
		H: Kr,
		ma: tn,
		X: rn,
		Y: nn,
		x: on,
		t: sn,
		sa: cn,
		na: hn,
		R: wn,
		I: bn,
		ua: $n,
		pa: Cn,
		N: xn,
		va: Nt,
		D: Sn,
		S: In,
		M: Dn,
		ia: Mn,
		da: An,
		ga: jn,
		ea: Un,
		fa: Vn,
		ha: Wn,
		$: Hn,
		V: zn,
		K: ma,
		C: ba,
		Z: ea,
		T: Oa,
		r: da,
		b: Kn,
		E: va,
		ka: Ca,
		c: ra,
		ja: Ta,
		h: ta,
		i: oa,
		q: ca,
		P: ya,
		v: fa,
		F: ha,
		L: pa,
		z: $a,
		J: _a,
		aa: xa,
		_: Sa,
		f: na,
		l: Yn,
		e: Jn,
		g: Qn,
		O: Pa,
		k: Zn,
		la: ga,
		o: la,
		B: ia,
		u: wa,
		W: ua,
		A: Ea,
		n: aa,
		G: sa,
		y: Gn
	};
	function Yn(t$1, e$1) {
		var r$1 = g$1();
		try {
			w$1(t$1)(e$1);
		} catch (n$1) {
			if (m$1(r$1), n$1 !== n$1 + 0) throw n$1;
			v(1, 0);
		}
	}
	function Zn(t$1, e$1, r$1, n$1, a$1) {
		var i$1 = g$1();
		try {
			w$1(t$1)(e$1, r$1, n$1, a$1);
		} catch (s$1) {
			if (m$1(i$1), s$1 !== s$1 + 0) throw s$1;
			v(1, 0);
		}
	}
	function Qn(t$1, e$1, r$1, n$1) {
		var a$1 = g$1();
		try {
			w$1(t$1)(e$1, r$1, n$1);
		} catch (i$1) {
			if (m$1(a$1), i$1 !== i$1 + 0) throw i$1;
			v(1, 0);
		}
	}
	function Jn(t$1, e$1, r$1) {
		var n$1 = g$1();
		try {
			w$1(t$1)(e$1, r$1);
		} catch (a$1) {
			if (m$1(n$1), a$1 !== a$1 + 0) throw a$1;
			v(1, 0);
		}
	}
	function Kn(t$1, e$1) {
		var r$1 = g$1();
		try {
			return w$1(t$1)(e$1);
		} catch (n$1) {
			if (m$1(r$1), n$1 !== n$1 + 0) throw n$1;
			v(1, 0);
		}
	}
	function ta(t$1, e$1, r$1, n$1) {
		var a$1 = g$1();
		try {
			return w$1(t$1)(e$1, r$1, n$1);
		} catch (i$1) {
			if (m$1(a$1), i$1 !== i$1 + 0) throw i$1;
			v(1, 0);
		}
	}
	function ea(t$1, e$1, r$1, n$1, a$1, i$1) {
		var s$1 = g$1();
		try {
			return w$1(t$1)(e$1, r$1, n$1, a$1, i$1);
		} catch (u$1) {
			if (m$1(s$1), u$1 !== u$1 + 0) throw u$1;
			v(1, 0);
		}
	}
	function ra(t$1, e$1, r$1) {
		var n$1 = g$1();
		try {
			return w$1(t$1)(e$1, r$1);
		} catch (a$1) {
			if (m$1(n$1), a$1 !== a$1 + 0) throw a$1;
			v(1, 0);
		}
	}
	function na(t$1) {
		var e$1 = g$1();
		try {
			w$1(t$1)();
		} catch (r$1) {
			if (m$1(e$1), r$1 !== r$1 + 0) throw r$1;
			v(1, 0);
		}
	}
	function aa(t$1, e$1, r$1, n$1, a$1, i$1, s$1, u$1, c$1, h$1, p$1) {
		var y$1 = g$1();
		try {
			w$1(t$1)(e$1, r$1, n$1, a$1, i$1, s$1, u$1, c$1, h$1, p$1);
		} catch (C$1) {
			if (m$1(y$1), C$1 !== C$1 + 0) throw C$1;
			v(1, 0);
		}
	}
	function oa(t$1, e$1, r$1, n$1, a$1) {
		var i$1 = g$1();
		try {
			return w$1(t$1)(e$1, r$1, n$1, a$1);
		} catch (s$1) {
			if (m$1(i$1), s$1 !== s$1 + 0) throw s$1;
			v(1, 0);
		}
	}
	function ia(t$1, e$1, r$1, n$1, a$1, i$1, s$1) {
		var u$1 = g$1();
		try {
			w$1(t$1)(e$1, r$1, n$1, a$1, i$1, s$1);
		} catch (c$1) {
			if (m$1(u$1), c$1 !== c$1 + 0) throw c$1;
			v(1, 0);
		}
	}
	function sa(t$1, e$1, r$1, n$1, a$1, i$1, s$1, u$1, c$1, h$1, p$1, y$1, C$1, P, S, x) {
		var O = g$1();
		try {
			w$1(t$1)(e$1, r$1, n$1, a$1, i$1, s$1, u$1, c$1, h$1, p$1, y$1, C$1, P, S, x);
		} catch (E$1) {
			if (m$1(O), E$1 !== E$1 + 0) throw E$1;
			v(1, 0);
		}
	}
	function ua(t$1, e$1, r$1, n$1, a$1, i$1, s$1, u$1, c$1) {
		var h$1 = g$1();
		try {
			w$1(t$1)(e$1, r$1, n$1, a$1, i$1, s$1, u$1, c$1);
		} catch (p$1) {
			if (m$1(h$1), p$1 !== p$1 + 0) throw p$1;
			v(1, 0);
		}
	}
	function ca(t$1, e$1, r$1, n$1, a$1, i$1) {
		var s$1 = g$1();
		try {
			return w$1(t$1)(e$1, r$1, n$1, a$1, i$1);
		} catch (u$1) {
			if (m$1(s$1), u$1 !== u$1 + 0) throw u$1;
			v(1, 0);
		}
	}
	function la(t$1, e$1, r$1, n$1, a$1, i$1) {
		var s$1 = g$1();
		try {
			w$1(t$1)(e$1, r$1, n$1, a$1, i$1);
		} catch (u$1) {
			if (m$1(s$1), u$1 !== u$1 + 0) throw u$1;
			v(1, 0);
		}
	}
	function fa(t$1, e$1, r$1, n$1, a$1, i$1, s$1) {
		var u$1 = g$1();
		try {
			return w$1(t$1)(e$1, r$1, n$1, a$1, i$1, s$1);
		} catch (c$1) {
			if (m$1(u$1), c$1 !== c$1 + 0) throw c$1;
			v(1, 0);
		}
	}
	function ha(t$1, e$1, r$1, n$1, a$1, i$1, s$1, u$1) {
		var c$1 = g$1();
		try {
			return w$1(t$1)(e$1, r$1, n$1, a$1, i$1, s$1, u$1);
		} catch (h$1) {
			if (m$1(c$1), h$1 !== h$1 + 0) throw h$1;
			v(1, 0);
		}
	}
	function da(t$1) {
		var e$1 = g$1();
		try {
			return w$1(t$1)();
		} catch (r$1) {
			if (m$1(e$1), r$1 !== r$1 + 0) throw r$1;
			v(1, 0);
		}
	}
	function pa(t$1, e$1, r$1, n$1, a$1, i$1, s$1, u$1, c$1) {
		var h$1 = g$1();
		try {
			return w$1(t$1)(e$1, r$1, n$1, a$1, i$1, s$1, u$1, c$1);
		} catch (p$1) {
			if (m$1(h$1), p$1 !== p$1 + 0) throw p$1;
			v(1, 0);
		}
	}
	function ya(t$1, e$1, r$1, n$1, a$1, i$1, s$1) {
		var u$1 = g$1();
		try {
			return w$1(t$1)(e$1, r$1, n$1, a$1, i$1, s$1);
		} catch (c$1) {
			if (m$1(u$1), c$1 !== c$1 + 0) throw c$1;
			v(1, 0);
		}
	}
	function va(t$1, e$1, r$1, n$1) {
		var a$1 = g$1();
		try {
			return w$1(t$1)(e$1, r$1, n$1);
		} catch (i$1) {
			if (m$1(a$1), i$1 !== i$1 + 0) throw i$1;
			v(1, 0);
		}
	}
	function ma(t$1, e$1, r$1, n$1) {
		var a$1 = g$1();
		try {
			return w$1(t$1)(e$1, r$1, n$1);
		} catch (i$1) {
			if (m$1(a$1), i$1 !== i$1 + 0) throw i$1;
			v(1, 0);
		}
	}
	function ga(t$1, e$1, r$1, n$1, a$1, i$1, s$1, u$1) {
		var c$1 = g$1();
		try {
			w$1(t$1)(e$1, r$1, n$1, a$1, i$1, s$1, u$1);
		} catch (h$1) {
			if (m$1(c$1), h$1 !== h$1 + 0) throw h$1;
			v(1, 0);
		}
	}
	function wa(t$1, e$1, r$1, n$1, a$1, i$1, s$1, u$1) {
		var c$1 = g$1();
		try {
			w$1(t$1)(e$1, r$1, n$1, a$1, i$1, s$1, u$1);
		} catch (h$1) {
			if (m$1(c$1), h$1 !== h$1 + 0) throw h$1;
			v(1, 0);
		}
	}
	function ba(t$1, e$1, r$1, n$1, a$1, i$1) {
		var s$1 = g$1();
		try {
			return w$1(t$1)(e$1, r$1, n$1, a$1, i$1);
		} catch (u$1) {
			if (m$1(s$1), u$1 !== u$1 + 0) throw u$1;
			v(1, 0);
		}
	}
	function $a(t$1, e$1, r$1, n$1, a$1, i$1, s$1, u$1, c$1, h$1) {
		var p$1 = g$1();
		try {
			return w$1(t$1)(e$1, r$1, n$1, a$1, i$1, s$1, u$1, c$1, h$1);
		} catch (y$1) {
			if (m$1(p$1), y$1 !== y$1 + 0) throw y$1;
			v(1, 0);
		}
	}
	function Ca(t$1, e$1, r$1) {
		var n$1 = g$1();
		try {
			return w$1(t$1)(e$1, r$1);
		} catch (a$1) {
			if (m$1(n$1), a$1 !== a$1 + 0) throw a$1;
			v(1, 0);
		}
	}
	function Ta(t$1, e$1, r$1, n$1, a$1) {
		var i$1 = g$1();
		try {
			return w$1(t$1)(e$1, r$1, n$1, a$1);
		} catch (s$1) {
			if (m$1(i$1), s$1 !== s$1 + 0) throw s$1;
			v(1, 0);
		}
	}
	function Ea(t$1, e$1, r$1, n$1, a$1, i$1, s$1, u$1, c$1, h$1) {
		var p$1 = g$1();
		try {
			w$1(t$1)(e$1, r$1, n$1, a$1, i$1, s$1, u$1, c$1, h$1);
		} catch (y$1) {
			if (m$1(p$1), y$1 !== y$1 + 0) throw y$1;
			v(1, 0);
		}
	}
	function Pa(t$1, e$1, r$1, n$1, a$1, i$1, s$1) {
		var u$1 = g$1();
		try {
			w$1(t$1)(e$1, r$1, n$1, a$1, i$1, s$1);
		} catch (c$1) {
			if (m$1(u$1), c$1 !== c$1 + 0) throw c$1;
			v(1, 0);
		}
	}
	function Oa(t$1, e$1, r$1, n$1) {
		var a$1 = g$1();
		try {
			return w$1(t$1)(e$1, r$1, n$1);
		} catch (i$1) {
			if (m$1(a$1), i$1 !== i$1 + 0) throw i$1;
			v(1, 0);
		}
	}
	function _a(t$1, e$1, r$1, n$1, a$1, i$1, s$1, u$1, c$1, h$1, p$1, y$1) {
		var C$1 = g$1();
		try {
			return w$1(t$1)(e$1, r$1, n$1, a$1, i$1, s$1, u$1, c$1, h$1, p$1, y$1);
		} catch (P) {
			if (m$1(C$1), P !== P + 0) throw P;
			v(1, 0);
		}
	}
	function xa(t$1, e$1, r$1, n$1, a$1, i$1, s$1) {
		var u$1 = g$1();
		try {
			return Me(t$1, e$1, r$1, n$1, a$1, i$1, s$1);
		} catch (c$1) {
			if (m$1(u$1), c$1 !== c$1 + 0) throw c$1;
			v(1, 0);
		}
	}
	function Sa(t$1, e$1, r$1, n$1, a$1) {
		var i$1 = g$1();
		try {
			return Ae(t$1, e$1, r$1, n$1, a$1);
		} catch (s$1) {
			if (m$1(i$1), s$1 !== s$1 + 0) throw s$1;
			v(1, 0);
		}
	}
	function Ia() {
		ar();
		function t$1() {
			var e$1, r$1;
			f$1.calledRun = !0, !ht && (or(), (e$1 = Qt) === null || e$1 === void 0 || e$1(f$1), (r$1 = f$1.onRuntimeInitialized) === null || r$1 === void 0 || r$1.call(f$1), ir());
		}
		f$1.setStatus ? (f$1.setStatus("Running..."), setTimeout(() => {
			setTimeout(() => f$1.setStatus(""), 1), t$1();
		}, 1)) : t$1();
	}
	var lt;
	return lt = await dr(), Ia(), ee ? l$1 = f$1 : l$1 = new Promise((t$1, e$1) => {
		Qt = t$1, Jt = e$1;
	}), l$1;
}
function qe(o$1) {
	return Xe(Zt, o$1);
}
function go(o$1) {
	qe({
		overrides: o$1,
		equalityFn: Object.is,
		fireImmediately: !1
	});
}
async function Za(o$1, l$1) {
	return Ya(Zt, o$1, l$1);
}
var wo = "85d46f55d7c86a4d09bb04273367408b19c324f582d040d018aecb25a9a82942", Ye = [
	["aztec", "Aztec"],
	["code_128", "Code128"],
	["code_39", "Code39"],
	["code_93", "Code93"],
	["codabar", "Codabar"],
	["databar", "DataBar"],
	["databar_expanded", "DataBarExpanded"],
	["databar_limited", "DataBarLimited"],
	["data_matrix", "DataMatrix"],
	["dx_film_edge", "DXFilmEdge"],
	["ean_13", "EAN-13"],
	["ean_8", "EAN-8"],
	["itf", "ITF"],
	["maxi_code", "MaxiCode"],
	["micro_qr_code", "MicroQRCode"],
	["pdf417", "PDF417"],
	["qr_code", "QRCode"],
	["rm_qr_code", "rMQRCode"],
	["upc_a", "UPC-A"],
	["upc_e", "UPC-E"],
	["linear_codes", "Linear-Codes"],
	["matrix_codes", "Matrix-Codes"],
	["any", "Any"]
], Qa = [...Ye, ["unknown"]].map((o$1) => o$1[0]), Yt = new Map(Ye);
function Ja(o$1) {
	for (const [l$1, d$1] of Yt) if (o$1 === d$1) return l$1;
	return "unknown";
}
function Ka(o$1) {
	if (Ze(o$1)) return {
		width: o$1.naturalWidth,
		height: o$1.naturalHeight
	};
	if (Qe(o$1)) return {
		width: o$1.width.baseVal.value,
		height: o$1.height.baseVal.value
	};
	if (Je(o$1)) return {
		width: o$1.videoWidth,
		height: o$1.videoHeight
	};
	if (tr(o$1)) return {
		width: o$1.width,
		height: o$1.height
	};
	if (rr(o$1)) return {
		width: o$1.displayWidth,
		height: o$1.displayHeight
	};
	if (Ke(o$1)) return {
		width: o$1.width,
		height: o$1.height
	};
	if (er(o$1)) return {
		width: o$1.width,
		height: o$1.height
	};
	throw new TypeError("The provided value is not of type '(Blob or HTMLCanvasElement or HTMLImageElement or HTMLVideoElement or ImageBitmap or ImageData or OffscreenCanvas or SVGImageElement or VideoFrame)'.");
}
function Ze(o$1) {
	var l$1, d$1;
	try {
		return o$1 instanceof ((d$1 = (l$1 = o$1 == null ? void 0 : o$1.ownerDocument) == null ? void 0 : l$1.defaultView) == null ? void 0 : d$1.HTMLImageElement);
	} catch {
		return !1;
	}
}
function Qe(o$1) {
	var l$1, d$1;
	try {
		return o$1 instanceof ((d$1 = (l$1 = o$1 == null ? void 0 : o$1.ownerDocument) == null ? void 0 : l$1.defaultView) == null ? void 0 : d$1.SVGImageElement);
	} catch {
		return !1;
	}
}
function Je(o$1) {
	var l$1, d$1;
	try {
		return o$1 instanceof ((d$1 = (l$1 = o$1 == null ? void 0 : o$1.ownerDocument) == null ? void 0 : l$1.defaultView) == null ? void 0 : d$1.HTMLVideoElement);
	} catch {
		return !1;
	}
}
function Ke(o$1) {
	var l$1, d$1;
	try {
		return o$1 instanceof ((d$1 = (l$1 = o$1 == null ? void 0 : o$1.ownerDocument) == null ? void 0 : l$1.defaultView) == null ? void 0 : d$1.HTMLCanvasElement);
	} catch {
		return !1;
	}
}
function tr(o$1) {
	try {
		return o$1 instanceof ImageBitmap || Object.prototype.toString.call(o$1) === "[object ImageBitmap]";
	} catch {
		return !1;
	}
}
function er(o$1) {
	try {
		return o$1 instanceof OffscreenCanvas || Object.prototype.toString.call(o$1) === "[object OffscreenCanvas]";
	} catch {
		return !1;
	}
}
function rr(o$1) {
	try {
		return o$1 instanceof VideoFrame || Object.prototype.toString.call(o$1) === "[object VideoFrame]";
	} catch {
		return !1;
	}
}
function to(o$1) {
	try {
		return o$1 instanceof Blob || Object.prototype.toString.call(o$1) === "[object Blob]";
	} catch {
		return !1;
	}
}
function eo(o$1) {
	try {
		return o$1 instanceof ImageData || Object.prototype.toString.call(o$1) === "[object ImageData]";
	} catch {
		return !1;
	}
}
function ro(o$1, l$1) {
	try {
		const d$1 = new OffscreenCanvas(o$1, l$1);
		if (d$1.getContext("2d") instanceof OffscreenCanvasRenderingContext2D) return d$1;
		throw void 0;
	} catch {
		const d$1 = document.createElement("canvas");
		return d$1.width = o$1, d$1.height = l$1, d$1;
	}
}
async function nr(o$1) {
	if (Ze(o$1) && !await io(o$1)) throw new DOMException("Failed to load or decode HTMLImageElement.", "InvalidStateError");
	if (Qe(o$1) && !await so(o$1)) throw new DOMException("Failed to load or decode SVGImageElement.", "InvalidStateError");
	if (rr(o$1) && uo(o$1)) throw new DOMException("VideoFrame is closed.", "InvalidStateError");
	if (Je(o$1) && (o$1.readyState === 0 || o$1.readyState === 1)) throw new DOMException("Invalid element or state.", "InvalidStateError");
	if (tr(o$1) && lo(o$1)) throw new DOMException("The image source is detached.", "InvalidStateError");
	const { width: l$1, height: d$1 } = Ka(o$1);
	if (l$1 === 0 || d$1 === 0) return null;
	const f$1 = ro(l$1, d$1).getContext("2d");
	f$1.drawImage(o$1, 0, 0);
	try {
		return f$1.getImageData(0, 0, l$1, d$1);
	} catch {
		throw new DOMException("Source would taint origin.", "SecurityError");
	}
}
async function no(o$1) {
	let l$1;
	try {
		l$1 = await createImageBitmap(o$1);
	} catch {
		try {
			if (globalThis.Image) {
				l$1 = new Image();
				let f$1 = "";
				try {
					f$1 = URL.createObjectURL(o$1), l$1.src = f$1, await l$1.decode();
				} finally {
					URL.revokeObjectURL(f$1);
				}
			} else return o$1;
		} catch {
			throw new DOMException("Failed to load or decode Blob.", "InvalidStateError");
		}
	}
	return await nr(l$1);
}
function ao(o$1) {
	const { width: l$1, height: d$1 } = o$1;
	if (l$1 === 0 || d$1 === 0) return null;
	const b = o$1.getContext("2d");
	try {
		return b.getImageData(0, 0, l$1, d$1);
	} catch {
		throw new DOMException("Source would taint origin.", "SecurityError");
	}
}
async function oo(o$1) {
	if (to(o$1)) return await no(o$1);
	if (eo(o$1)) {
		if (co(o$1)) throw new DOMException("The image data has been detached.", "InvalidStateError");
		return o$1;
	}
	return Ke(o$1) || er(o$1) ? ao(o$1) : await nr(o$1);
}
async function io(o$1) {
	try {
		return await o$1.decode(), !0;
	} catch {
		return !1;
	}
}
async function so(o$1) {
	var l$1;
	try {
		return await ((l$1 = o$1.decode) == null ? void 0 : l$1.call(o$1)), !0;
	} catch {
		return !1;
	}
}
function uo(o$1) {
	return o$1.format === null;
}
function co(o$1) {
	return o$1.data.buffer.byteLength === 0;
}
function lo(o$1) {
	return o$1.width === 0 && o$1.height === 0;
}
function Ge(o$1, l$1) {
	return fo(o$1) ? new DOMException(`${l$1}: ${o$1.message}`, o$1.name) : ho(o$1) ? new o$1.constructor(`${l$1}: ${o$1.message}`) : /* @__PURE__ */ new Error(`${l$1}: ${o$1}`);
}
function fo(o$1) {
	return o$1 instanceof DOMException || Object.prototype.toString.call(o$1) === "[object DOMException]";
}
function ho(o$1) {
	return o$1 instanceof Error || Object.prototype.toString.call(o$1) === "[object Error]";
}
var ft;
var bo = class {
	constructor(l$1 = {}) {
		He(this, ft);
		var d$1;
		try {
			const b = (d$1 = l$1 == null ? void 0 : l$1.formats) == null ? void 0 : d$1.filter((f$1) => f$1 !== "unknown");
			if ((b == null ? void 0 : b.length) === 0) throw new TypeError("Hint option provided, but is empty.");
			for (const f$1 of b != null ? b : []) if (!Yt.has(f$1)) throw new TypeError(`Failed to read the 'formats' property from 'BarcodeDetectorOptions': The provided value '${f$1}' is not a valid enum value of type BarcodeFormat.`);
			ke(this, ft, b != null ? b : []), qe({ fireImmediately: !0 }).catch(() => {});
		} catch (b) {
			throw Ge(b, "Failed to construct 'BarcodeDetector'");
		}
	}
	static async getSupportedFormats() {
		return Qa.filter((l$1) => l$1 !== "unknown");
	}
	async detect(l$1) {
		try {
			const d$1 = await oo(l$1);
			if (d$1 === null) return [];
			let b;
			const f$1 = {
				tryCode39ExtendedMode: !1,
				textMode: "Plain",
				formats: We(this, ft).map((I$1) => Yt.get(I$1))
			};
			try {
				b = await Za(d$1, f$1);
			} catch (I$1) {
				throw console.error(I$1), new DOMException("Barcode detection service unavailable.", "NotSupportedError");
			}
			return b.map((I$1) => {
				const { topLeft: { x: D$1, y: M$1 }, topRight: { x: _, y: A }, bottomLeft: { x: U, y: G$1 }, bottomRight: { x: tt, y: X } } = I$1.position, nt = Math.min(D$1, _, U, tt), V$1 = Math.min(M$1, A, G$1, X), q$1 = Math.max(D$1, _, U, tt), ht = Math.max(M$1, A, G$1, X);
				return {
					boundingBox: new DOMRectReadOnly(nt, V$1, q$1 - nt, ht - V$1),
					rawValue: I$1.text,
					format: Ja(I$1.format),
					cornerPoints: [
						{
							x: D$1,
							y: M$1
						},
						{
							x: _,
							y: A
						},
						{
							x: tt,
							y: X
						},
						{
							x: U,
							y: G$1
						}
					]
				};
			});
		} catch (d$1) {
			throw Ge(d$1, "Failed to execute 'detect' on 'BarcodeDetector'");
		}
	}
};
ft = /* @__PURE__ */ new WeakMap();

//#endregion
//#region node_modules/barcode-detector/dist/es/polyfill.js
globalThis.BarcodeDetector ?? (globalThis.BarcodeDetector = bo);

//#endregion
//#region node_modules/webrtc-adapter/src/js/utils.js
var import_jsx_runtime = require_jsx_runtime();
var import_react = require_react();
var logDisabled_ = true;
var deprecationWarnings_ = true;
/**
* Extract browser version out of the provided user agent string.
*
* @param {!string} uastring userAgent string.
* @param {!string} expr Regular expression used as match criteria.
* @param {!number} pos position in the version string to be returned.
* @return {!number} browser version.
*/
function extractVersion(uastring, expr, pos) {
	const match = uastring.match(expr);
	return match && match.length >= pos && parseFloat(match[pos], 10);
}
function wrapPeerConnectionEvent(window$1, eventNameToWrap, wrapper) {
	if (!window$1.RTCPeerConnection) return;
	const proto = window$1.RTCPeerConnection.prototype;
	const nativeAddEventListener = proto.addEventListener;
	proto.addEventListener = function(nativeEventName, cb) {
		if (nativeEventName !== eventNameToWrap) return nativeAddEventListener.apply(this, arguments);
		const wrappedCallback = (e$1) => {
			const modifiedEvent = wrapper(e$1);
			if (modifiedEvent) if (cb.handleEvent) cb.handleEvent(modifiedEvent);
			else cb(modifiedEvent);
		};
		this._eventMap = this._eventMap || {};
		if (!this._eventMap[eventNameToWrap]) this._eventMap[eventNameToWrap] = /* @__PURE__ */ new Map();
		this._eventMap[eventNameToWrap].set(cb, wrappedCallback);
		return nativeAddEventListener.apply(this, [nativeEventName, wrappedCallback]);
	};
	const nativeRemoveEventListener = proto.removeEventListener;
	proto.removeEventListener = function(nativeEventName, cb) {
		if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[eventNameToWrap]) return nativeRemoveEventListener.apply(this, arguments);
		if (!this._eventMap[eventNameToWrap].has(cb)) return nativeRemoveEventListener.apply(this, arguments);
		const unwrappedCb = this._eventMap[eventNameToWrap].get(cb);
		this._eventMap[eventNameToWrap].delete(cb);
		if (this._eventMap[eventNameToWrap].size === 0) delete this._eventMap[eventNameToWrap];
		if (Object.keys(this._eventMap).length === 0) delete this._eventMap;
		return nativeRemoveEventListener.apply(this, [nativeEventName, unwrappedCb]);
	};
	Object.defineProperty(proto, "on" + eventNameToWrap, {
		get() {
			return this["_on" + eventNameToWrap];
		},
		set(cb) {
			if (this["_on" + eventNameToWrap]) {
				this.removeEventListener(eventNameToWrap, this["_on" + eventNameToWrap]);
				delete this["_on" + eventNameToWrap];
			}
			if (cb) this.addEventListener(eventNameToWrap, this["_on" + eventNameToWrap] = cb);
		},
		enumerable: true,
		configurable: true
	});
}
function disableLog(bool) {
	if (typeof bool !== "boolean") return /* @__PURE__ */ new Error("Argument type: " + typeof bool + ". Please use a boolean.");
	logDisabled_ = bool;
	return bool ? "adapter.js logging disabled" : "adapter.js logging enabled";
}
/**
* Disable or enable deprecation warnings
* @param {!boolean} bool set to true to disable warnings.
*/
function disableWarnings(bool) {
	if (typeof bool !== "boolean") return /* @__PURE__ */ new Error("Argument type: " + typeof bool + ". Please use a boolean.");
	deprecationWarnings_ = !bool;
	return "adapter.js deprecation warnings " + (bool ? "disabled" : "enabled");
}
function log() {
	if (typeof window === "object") {
		if (logDisabled_) return;
		if (typeof console !== "undefined" && typeof console.log === "function") console.log.apply(console, arguments);
	}
}
/**
* Shows a deprecation warning suggesting the modern and spec-compatible API.
*/
function deprecated(oldMethod, newMethod) {
	if (!deprecationWarnings_) return;
	console.warn(oldMethod + " is deprecated, please use " + newMethod + " instead.");
}
/**
* Browser detector.
*
* @return {object} result containing browser and version
*     properties.
*/
function detectBrowser(window$1) {
	const result = {
		browser: null,
		version: null
	};
	if (typeof window$1 === "undefined" || !window$1.navigator || !window$1.navigator.userAgent) {
		result.browser = "Not a browser.";
		return result;
	}
	const { navigator: navigator$1 } = window$1;
	if (navigator$1.userAgentData && navigator$1.userAgentData.brands) {
		const chromium = navigator$1.userAgentData.brands.find((brand) => {
			return brand.brand === "Chromium";
		});
		if (chromium) return {
			browser: "chrome",
			version: parseInt(chromium.version, 10)
		};
	}
	if (navigator$1.mozGetUserMedia) {
		result.browser = "firefox";
		result.version = parseInt(extractVersion(navigator$1.userAgent, /Firefox\/(\d+)\./, 1));
	} else if (navigator$1.webkitGetUserMedia || window$1.isSecureContext === false && window$1.webkitRTCPeerConnection) {
		result.browser = "chrome";
		result.version = parseInt(extractVersion(navigator$1.userAgent, /Chrom(e|ium)\/(\d+)\./, 2));
	} else if (window$1.RTCPeerConnection && navigator$1.userAgent.match(/AppleWebKit\/(\d+)\./)) {
		result.browser = "safari";
		result.version = parseInt(extractVersion(navigator$1.userAgent, /AppleWebKit\/(\d+)\./, 1));
		result.supportsUnifiedPlan = window$1.RTCRtpTransceiver && "currentDirection" in window$1.RTCRtpTransceiver.prototype;
		result._safariVersion = extractVersion(navigator$1.userAgent, /Version\/(\d+(\.?\d+))/, 1);
	} else {
		result.browser = "Not a supported browser.";
		return result;
	}
	return result;
}
/**
* Checks if something is an object.
*
* @param {*} val The something you want to check.
* @return true if val is an object, false otherwise.
*/
function isObject(val) {
	return Object.prototype.toString.call(val) === "[object Object]";
}
/**
* Remove all empty objects and undefined values
* from a nested object -- an enhanced and vanilla version
* of Lodash's `compact`.
*/
function compactObject(data) {
	if (!isObject(data)) return data;
	return Object.keys(data).reduce(function(accumulator, key) {
		const isObj = isObject(data[key]);
		const value = isObj ? compactObject(data[key]) : data[key];
		const isEmptyObject = isObj && !Object.keys(value).length;
		if (value === void 0 || isEmptyObject) return accumulator;
		return Object.assign(accumulator, { [key]: value });
	}, {});
}
function walkStats(stats, base, resultSet) {
	if (!base || resultSet.has(base.id)) return;
	resultSet.set(base.id, base);
	Object.keys(base).forEach((name) => {
		if (name.endsWith("Id")) walkStats(stats, stats.get(base[name]), resultSet);
		else if (name.endsWith("Ids")) base[name].forEach((id) => {
			walkStats(stats, stats.get(id), resultSet);
		});
	});
}
function filterStats(result, track, outbound) {
	const streamStatsType = outbound ? "outbound-rtp" : "inbound-rtp";
	const filteredResult = /* @__PURE__ */ new Map();
	if (track === null) return filteredResult;
	const trackStats = [];
	result.forEach((value) => {
		if (value.type === "track" && value.trackIdentifier === track.id) trackStats.push(value);
	});
	trackStats.forEach((trackStat) => {
		result.forEach((stats) => {
			if (stats.type === streamStatsType && stats.trackId === trackStat.id) walkStats(result, stats, filteredResult);
		});
	});
	return filteredResult;
}

//#endregion
//#region node_modules/webrtc-adapter/src/js/chrome/getusermedia.js
var logging = log;
function shimGetUserMedia$2(window$1, browserDetails) {
	const navigator$1 = window$1 && window$1.navigator;
	if (!navigator$1.mediaDevices) return;
	const constraintsToChrome_ = function(c$1) {
		if (typeof c$1 !== "object" || c$1.mandatory || c$1.optional) return c$1;
		const cc = {};
		Object.keys(c$1).forEach((key) => {
			if (key === "require" || key === "advanced" || key === "mediaSource") return;
			const r$1 = typeof c$1[key] === "object" ? c$1[key] : { ideal: c$1[key] };
			if (r$1.exact !== void 0 && typeof r$1.exact === "number") r$1.min = r$1.max = r$1.exact;
			const oldname_ = function(prefix, name) {
				if (prefix) return prefix + name.charAt(0).toUpperCase() + name.slice(1);
				return name === "deviceId" ? "sourceId" : name;
			};
			if (r$1.ideal !== void 0) {
				cc.optional = cc.optional || [];
				let oc = {};
				if (typeof r$1.ideal === "number") {
					oc[oldname_("min", key)] = r$1.ideal;
					cc.optional.push(oc);
					oc = {};
					oc[oldname_("max", key)] = r$1.ideal;
					cc.optional.push(oc);
				} else {
					oc[oldname_("", key)] = r$1.ideal;
					cc.optional.push(oc);
				}
			}
			if (r$1.exact !== void 0 && typeof r$1.exact !== "number") {
				cc.mandatory = cc.mandatory || {};
				cc.mandatory[oldname_("", key)] = r$1.exact;
			} else ["min", "max"].forEach((mix) => {
				if (r$1[mix] !== void 0) {
					cc.mandatory = cc.mandatory || {};
					cc.mandatory[oldname_(mix, key)] = r$1[mix];
				}
			});
		});
		if (c$1.advanced) cc.optional = (cc.optional || []).concat(c$1.advanced);
		return cc;
	};
	const shimConstraints_ = function(constraints, func) {
		if (browserDetails.version >= 61) return func(constraints);
		constraints = JSON.parse(JSON.stringify(constraints));
		if (constraints && typeof constraints.audio === "object") {
			const remap = function(obj, a$1, b) {
				if (a$1 in obj && !(b in obj)) {
					obj[b] = obj[a$1];
					delete obj[a$1];
				}
			};
			constraints = JSON.parse(JSON.stringify(constraints));
			remap(constraints.audio, "autoGainControl", "googAutoGainControl");
			remap(constraints.audio, "noiseSuppression", "googNoiseSuppression");
			constraints.audio = constraintsToChrome_(constraints.audio);
		}
		if (constraints && typeof constraints.video === "object") {
			let face = constraints.video.facingMode;
			face = face && (typeof face === "object" ? face : { ideal: face });
			const getSupportedFacingModeLies = browserDetails.version < 66;
			if (face && (face.exact === "user" || face.exact === "environment" || face.ideal === "user" || face.ideal === "environment") && !(navigator$1.mediaDevices.getSupportedConstraints && navigator$1.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {
				delete constraints.video.facingMode;
				let matches;
				if (face.exact === "environment" || face.ideal === "environment") matches = ["back", "rear"];
				else if (face.exact === "user" || face.ideal === "user") matches = ["front"];
				if (matches) return navigator$1.mediaDevices.enumerateDevices().then((devices) => {
					devices = devices.filter((d$1) => d$1.kind === "videoinput");
					let dev = devices.find((d$1) => matches.some((match) => d$1.label.toLowerCase().includes(match)));
					if (!dev && devices.length && matches.includes("back")) dev = devices[devices.length - 1];
					if (dev) constraints.video.deviceId = face.exact ? { exact: dev.deviceId } : { ideal: dev.deviceId };
					constraints.video = constraintsToChrome_(constraints.video);
					logging("chrome: " + JSON.stringify(constraints));
					return func(constraints);
				});
			}
			constraints.video = constraintsToChrome_(constraints.video);
		}
		logging("chrome: " + JSON.stringify(constraints));
		return func(constraints);
	};
	const shimError_ = function(e$1) {
		if (browserDetails.version >= 64) return e$1;
		return {
			name: {
				PermissionDeniedError: "NotAllowedError",
				PermissionDismissedError: "NotAllowedError",
				InvalidStateError: "NotAllowedError",
				DevicesNotFoundError: "NotFoundError",
				ConstraintNotSatisfiedError: "OverconstrainedError",
				TrackStartError: "NotReadableError",
				MediaDeviceFailedDueToShutdown: "NotAllowedError",
				MediaDeviceKillSwitchOn: "NotAllowedError",
				TabCaptureError: "AbortError",
				ScreenCaptureError: "AbortError",
				DeviceCaptureError: "AbortError"
			}[e$1.name] || e$1.name,
			message: e$1.message,
			constraint: e$1.constraint || e$1.constraintName,
			toString() {
				return this.name + (this.message && ": ") + this.message;
			}
		};
	};
	const getUserMedia_ = function(constraints, onSuccess, onError) {
		shimConstraints_(constraints, (c$1) => {
			navigator$1.webkitGetUserMedia(c$1, onSuccess, (e$1) => {
				if (onError) onError(shimError_(e$1));
			});
		});
	};
	navigator$1.getUserMedia = getUserMedia_.bind(navigator$1);
	if (navigator$1.mediaDevices.getUserMedia) {
		const origGetUserMedia = navigator$1.mediaDevices.getUserMedia.bind(navigator$1.mediaDevices);
		navigator$1.mediaDevices.getUserMedia = function(cs) {
			return shimConstraints_(cs, (c$1) => origGetUserMedia(c$1).then((stream) => {
				if (c$1.audio && !stream.getAudioTracks().length || c$1.video && !stream.getVideoTracks().length) {
					stream.getTracks().forEach((track) => {
						track.stop();
					});
					throw new DOMException("", "NotFoundError");
				}
				return stream;
			}, (e$1) => Promise.reject(shimError_(e$1))));
		};
	}
}

//#endregion
//#region node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js
var chrome_shim_exports = /* @__PURE__ */ __export({
	fixNegotiationNeeded: () => fixNegotiationNeeded,
	shimAddTrackRemoveTrack: () => shimAddTrackRemoveTrack,
	shimAddTrackRemoveTrackWithNative: () => shimAddTrackRemoveTrackWithNative,
	shimGetSendersWithDtmf: () => shimGetSendersWithDtmf,
	shimGetUserMedia: () => shimGetUserMedia$2,
	shimMediaStream: () => shimMediaStream,
	shimOnTrack: () => shimOnTrack$1,
	shimPeerConnection: () => shimPeerConnection$1,
	shimSenderReceiverGetStats: () => shimSenderReceiverGetStats
});
function shimMediaStream(window$1) {
	window$1.MediaStream = window$1.MediaStream || window$1.webkitMediaStream;
}
function shimOnTrack$1(window$1) {
	if (typeof window$1 === "object" && window$1.RTCPeerConnection && !("ontrack" in window$1.RTCPeerConnection.prototype)) {
		Object.defineProperty(window$1.RTCPeerConnection.prototype, "ontrack", {
			get() {
				return this._ontrack;
			},
			set(f$1) {
				if (this._ontrack) this.removeEventListener("track", this._ontrack);
				this.addEventListener("track", this._ontrack = f$1);
			},
			enumerable: true,
			configurable: true
		});
		const origSetRemoteDescription = window$1.RTCPeerConnection.prototype.setRemoteDescription;
		window$1.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
			if (!this._ontrackpoly) {
				this._ontrackpoly = (e$1) => {
					e$1.stream.addEventListener("addtrack", (te) => {
						let receiver;
						if (window$1.RTCPeerConnection.prototype.getReceivers) receiver = this.getReceivers().find((r$1) => r$1.track && r$1.track.id === te.track.id);
						else receiver = { track: te.track };
						const event = new Event("track");
						event.track = te.track;
						event.receiver = receiver;
						event.transceiver = { receiver };
						event.streams = [e$1.stream];
						this.dispatchEvent(event);
					});
					e$1.stream.getTracks().forEach((track) => {
						let receiver;
						if (window$1.RTCPeerConnection.prototype.getReceivers) receiver = this.getReceivers().find((r$1) => r$1.track && r$1.track.id === track.id);
						else receiver = { track };
						const event = new Event("track");
						event.track = track;
						event.receiver = receiver;
						event.transceiver = { receiver };
						event.streams = [e$1.stream];
						this.dispatchEvent(event);
					});
				};
				this.addEventListener("addstream", this._ontrackpoly);
			}
			return origSetRemoteDescription.apply(this, arguments);
		};
	} else wrapPeerConnectionEvent(window$1, "track", (e$1) => {
		if (!e$1.transceiver) Object.defineProperty(e$1, "transceiver", { value: { receiver: e$1.receiver } });
		return e$1;
	});
}
function shimGetSendersWithDtmf(window$1) {
	if (typeof window$1 === "object" && window$1.RTCPeerConnection && !("getSenders" in window$1.RTCPeerConnection.prototype) && "createDTMFSender" in window$1.RTCPeerConnection.prototype) {
		const shimSenderWithDtmf = function(pc, track) {
			return {
				track,
				get dtmf() {
					if (this._dtmf === void 0) if (track.kind === "audio") this._dtmf = pc.createDTMFSender(track);
					else this._dtmf = null;
					return this._dtmf;
				},
				_pc: pc
			};
		};
		if (!window$1.RTCPeerConnection.prototype.getSenders) {
			window$1.RTCPeerConnection.prototype.getSenders = function getSenders() {
				this._senders = this._senders || [];
				return this._senders.slice();
			};
			const origAddTrack = window$1.RTCPeerConnection.prototype.addTrack;
			window$1.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
				let sender = origAddTrack.apply(this, arguments);
				if (!sender) {
					sender = shimSenderWithDtmf(this, track);
					this._senders.push(sender);
				}
				return sender;
			};
			const origRemoveTrack = window$1.RTCPeerConnection.prototype.removeTrack;
			window$1.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
				origRemoveTrack.apply(this, arguments);
				const idx = this._senders.indexOf(sender);
				if (idx !== -1) this._senders.splice(idx, 1);
			};
		}
		const origAddStream = window$1.RTCPeerConnection.prototype.addStream;
		window$1.RTCPeerConnection.prototype.addStream = function addStream(stream) {
			this._senders = this._senders || [];
			origAddStream.apply(this, [stream]);
			stream.getTracks().forEach((track) => {
				this._senders.push(shimSenderWithDtmf(this, track));
			});
		};
		const origRemoveStream = window$1.RTCPeerConnection.prototype.removeStream;
		window$1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
			this._senders = this._senders || [];
			origRemoveStream.apply(this, [stream]);
			stream.getTracks().forEach((track) => {
				const sender = this._senders.find((s$1) => s$1.track === track);
				if (sender) this._senders.splice(this._senders.indexOf(sender), 1);
			});
		};
	} else if (typeof window$1 === "object" && window$1.RTCPeerConnection && "getSenders" in window$1.RTCPeerConnection.prototype && "createDTMFSender" in window$1.RTCPeerConnection.prototype && window$1.RTCRtpSender && !("dtmf" in window$1.RTCRtpSender.prototype)) {
		const origGetSenders = window$1.RTCPeerConnection.prototype.getSenders;
		window$1.RTCPeerConnection.prototype.getSenders = function getSenders() {
			const senders = origGetSenders.apply(this, []);
			senders.forEach((sender) => sender._pc = this);
			return senders;
		};
		Object.defineProperty(window$1.RTCRtpSender.prototype, "dtmf", { get() {
			if (this._dtmf === void 0) if (this.track.kind === "audio") this._dtmf = this._pc.createDTMFSender(this.track);
			else this._dtmf = null;
			return this._dtmf;
		} });
	}
}
function shimSenderReceiverGetStats(window$1) {
	if (!(typeof window$1 === "object" && window$1.RTCPeerConnection && window$1.RTCRtpSender && window$1.RTCRtpReceiver)) return;
	if (!("getStats" in window$1.RTCRtpSender.prototype)) {
		const origGetSenders = window$1.RTCPeerConnection.prototype.getSenders;
		if (origGetSenders) window$1.RTCPeerConnection.prototype.getSenders = function getSenders() {
			const senders = origGetSenders.apply(this, []);
			senders.forEach((sender) => sender._pc = this);
			return senders;
		};
		const origAddTrack = window$1.RTCPeerConnection.prototype.addTrack;
		if (origAddTrack) window$1.RTCPeerConnection.prototype.addTrack = function addTrack() {
			const sender = origAddTrack.apply(this, arguments);
			sender._pc = this;
			return sender;
		};
		window$1.RTCRtpSender.prototype.getStats = function getStats() {
			const sender = this;
			return this._pc.getStats().then((result) => filterStats(result, sender.track, true));
		};
	}
	if (!("getStats" in window$1.RTCRtpReceiver.prototype)) {
		const origGetReceivers = window$1.RTCPeerConnection.prototype.getReceivers;
		if (origGetReceivers) window$1.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
			const receivers = origGetReceivers.apply(this, []);
			receivers.forEach((receiver) => receiver._pc = this);
			return receivers;
		};
		wrapPeerConnectionEvent(window$1, "track", (e$1) => {
			e$1.receiver._pc = e$1.srcElement;
			return e$1;
		});
		window$1.RTCRtpReceiver.prototype.getStats = function getStats() {
			const receiver = this;
			return this._pc.getStats().then((result) => filterStats(result, receiver.track, false));
		};
	}
	if (!("getStats" in window$1.RTCRtpSender.prototype && "getStats" in window$1.RTCRtpReceiver.prototype)) return;
	const origGetStats = window$1.RTCPeerConnection.prototype.getStats;
	window$1.RTCPeerConnection.prototype.getStats = function getStats() {
		if (arguments.length > 0 && arguments[0] instanceof window$1.MediaStreamTrack) {
			const track = arguments[0];
			let sender;
			let receiver;
			let err;
			this.getSenders().forEach((s$1) => {
				if (s$1.track === track) if (sender) err = true;
				else sender = s$1;
			});
			this.getReceivers().forEach((r$1) => {
				if (r$1.track === track) if (receiver) err = true;
				else receiver = r$1;
				return r$1.track === track;
			});
			if (err || sender && receiver) return Promise.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError"));
			else if (sender) return sender.getStats();
			else if (receiver) return receiver.getStats();
			return Promise.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError"));
		}
		return origGetStats.apply(this, arguments);
	};
}
function shimAddTrackRemoveTrackWithNative(window$1) {
	window$1.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
		this._shimmedLocalStreams = this._shimmedLocalStreams || {};
		return Object.keys(this._shimmedLocalStreams).map((streamId) => this._shimmedLocalStreams[streamId][0]);
	};
	const origAddTrack = window$1.RTCPeerConnection.prototype.addTrack;
	window$1.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
		if (!stream) return origAddTrack.apply(this, arguments);
		this._shimmedLocalStreams = this._shimmedLocalStreams || {};
		const sender = origAddTrack.apply(this, arguments);
		if (!this._shimmedLocalStreams[stream.id]) this._shimmedLocalStreams[stream.id] = [stream, sender];
		else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) this._shimmedLocalStreams[stream.id].push(sender);
		return sender;
	};
	const origAddStream = window$1.RTCPeerConnection.prototype.addStream;
	window$1.RTCPeerConnection.prototype.addStream = function addStream(stream) {
		this._shimmedLocalStreams = this._shimmedLocalStreams || {};
		stream.getTracks().forEach((track) => {
			if (this.getSenders().find((s$1) => s$1.track === track)) throw new DOMException("Track already exists.", "InvalidAccessError");
		});
		const existingSenders = this.getSenders();
		origAddStream.apply(this, arguments);
		const newSenders = this.getSenders().filter((newSender) => existingSenders.indexOf(newSender) === -1);
		this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);
	};
	const origRemoveStream = window$1.RTCPeerConnection.prototype.removeStream;
	window$1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
		this._shimmedLocalStreams = this._shimmedLocalStreams || {};
		delete this._shimmedLocalStreams[stream.id];
		return origRemoveStream.apply(this, arguments);
	};
	const origRemoveTrack = window$1.RTCPeerConnection.prototype.removeTrack;
	window$1.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
		this._shimmedLocalStreams = this._shimmedLocalStreams || {};
		if (sender) Object.keys(this._shimmedLocalStreams).forEach((streamId) => {
			const idx = this._shimmedLocalStreams[streamId].indexOf(sender);
			if (idx !== -1) this._shimmedLocalStreams[streamId].splice(idx, 1);
			if (this._shimmedLocalStreams[streamId].length === 1) delete this._shimmedLocalStreams[streamId];
		});
		return origRemoveTrack.apply(this, arguments);
	};
}
function shimAddTrackRemoveTrack(window$1, browserDetails) {
	if (!window$1.RTCPeerConnection) return;
	if (window$1.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) return shimAddTrackRemoveTrackWithNative(window$1);
	const origGetLocalStreams = window$1.RTCPeerConnection.prototype.getLocalStreams;
	window$1.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
		const nativeStreams = origGetLocalStreams.apply(this);
		this._reverseStreams = this._reverseStreams || {};
		return nativeStreams.map((stream) => this._reverseStreams[stream.id]);
	};
	const origAddStream = window$1.RTCPeerConnection.prototype.addStream;
	window$1.RTCPeerConnection.prototype.addStream = function addStream(stream) {
		this._streams = this._streams || {};
		this._reverseStreams = this._reverseStreams || {};
		stream.getTracks().forEach((track) => {
			if (this.getSenders().find((s$1) => s$1.track === track)) throw new DOMException("Track already exists.", "InvalidAccessError");
		});
		if (!this._reverseStreams[stream.id]) {
			const newStream = new window$1.MediaStream(stream.getTracks());
			this._streams[stream.id] = newStream;
			this._reverseStreams[newStream.id] = stream;
			stream = newStream;
		}
		origAddStream.apply(this, [stream]);
	};
	const origRemoveStream = window$1.RTCPeerConnection.prototype.removeStream;
	window$1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
		this._streams = this._streams || {};
		this._reverseStreams = this._reverseStreams || {};
		origRemoveStream.apply(this, [this._streams[stream.id] || stream]);
		delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];
		delete this._streams[stream.id];
	};
	window$1.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
		if (this.signalingState === "closed") throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
		const streams = [].slice.call(arguments, 1);
		if (streams.length !== 1 || !streams[0].getTracks().find((t$1) => t$1 === track)) throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError");
		if (this.getSenders().find((s$1) => s$1.track === track)) throw new DOMException("Track already exists.", "InvalidAccessError");
		this._streams = this._streams || {};
		this._reverseStreams = this._reverseStreams || {};
		const oldStream = this._streams[stream.id];
		if (oldStream) {
			oldStream.addTrack(track);
			Promise.resolve().then(() => {
				this.dispatchEvent(new Event("negotiationneeded"));
			});
		} else {
			const newStream = new window$1.MediaStream([track]);
			this._streams[stream.id] = newStream;
			this._reverseStreams[newStream.id] = stream;
			this.addStream(newStream);
		}
		return this.getSenders().find((s$1) => s$1.track === track);
	};
	function replaceInternalStreamId(pc, description) {
		let sdp = description.sdp;
		Object.keys(pc._reverseStreams || []).forEach((internalId) => {
			const externalStream = pc._reverseStreams[internalId];
			const internalStream = pc._streams[externalStream.id];
			sdp = sdp.replace(new RegExp(internalStream.id, "g"), externalStream.id);
		});
		return new RTCSessionDescription({
			type: description.type,
			sdp
		});
	}
	function replaceExternalStreamId(pc, description) {
		let sdp = description.sdp;
		Object.keys(pc._reverseStreams || []).forEach((internalId) => {
			const externalStream = pc._reverseStreams[internalId];
			const internalStream = pc._streams[externalStream.id];
			sdp = sdp.replace(new RegExp(externalStream.id, "g"), internalStream.id);
		});
		return new RTCSessionDescription({
			type: description.type,
			sdp
		});
	}
	["createOffer", "createAnswer"].forEach(function(method) {
		const nativeMethod = window$1.RTCPeerConnection.prototype[method];
		const methodObj = { [method]() {
			const args = arguments;
			if (arguments.length && typeof arguments[0] === "function") return nativeMethod.apply(this, [
				(description) => {
					const desc = replaceInternalStreamId(this, description);
					args[0].apply(null, [desc]);
				},
				(err) => {
					if (args[1]) args[1].apply(null, err);
				},
				arguments[2]
			]);
			return nativeMethod.apply(this, arguments).then((description) => replaceInternalStreamId(this, description));
		} };
		window$1.RTCPeerConnection.prototype[method] = methodObj[method];
	});
	const origSetLocalDescription = window$1.RTCPeerConnection.prototype.setLocalDescription;
	window$1.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {
		if (!arguments.length || !arguments[0].type) return origSetLocalDescription.apply(this, arguments);
		arguments[0] = replaceExternalStreamId(this, arguments[0]);
		return origSetLocalDescription.apply(this, arguments);
	};
	const origLocalDescription = Object.getOwnPropertyDescriptor(window$1.RTCPeerConnection.prototype, "localDescription");
	Object.defineProperty(window$1.RTCPeerConnection.prototype, "localDescription", { get() {
		const description = origLocalDescription.get.apply(this);
		if (description.type === "") return description;
		return replaceInternalStreamId(this, description);
	} });
	window$1.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
		if (this.signalingState === "closed") throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
		if (!sender._pc) throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
		if (!(sender._pc === this)) throw new DOMException("Sender was not created by this connection.", "InvalidAccessError");
		this._streams = this._streams || {};
		let stream;
		Object.keys(this._streams).forEach((streamid) => {
			if (this._streams[streamid].getTracks().find((track) => sender.track === track)) stream = this._streams[streamid];
		});
		if (stream) {
			if (stream.getTracks().length === 1) this.removeStream(this._reverseStreams[stream.id]);
			else stream.removeTrack(sender.track);
			this.dispatchEvent(new Event("negotiationneeded"));
		}
	};
}
function shimPeerConnection$1(window$1, browserDetails) {
	if (!window$1.RTCPeerConnection && window$1.webkitRTCPeerConnection) window$1.RTCPeerConnection = window$1.webkitRTCPeerConnection;
	if (!window$1.RTCPeerConnection) return;
	if (browserDetails.version < 53) [
		"setLocalDescription",
		"setRemoteDescription",
		"addIceCandidate"
	].forEach(function(method) {
		const nativeMethod = window$1.RTCPeerConnection.prototype[method];
		const methodObj = { [method]() {
			arguments[0] = new (method === "addIceCandidate" ? window$1.RTCIceCandidate : window$1.RTCSessionDescription)(arguments[0]);
			return nativeMethod.apply(this, arguments);
		} };
		window$1.RTCPeerConnection.prototype[method] = methodObj[method];
	});
}
function fixNegotiationNeeded(window$1, browserDetails) {
	wrapPeerConnectionEvent(window$1, "negotiationneeded", (e$1) => {
		const pc = e$1.target;
		if (browserDetails.version < 72 || pc.getConfiguration && pc.getConfiguration().sdpSemantics === "plan-b") {
			if (pc.signalingState !== "stable") return;
		}
		return e$1;
	});
}

//#endregion
//#region node_modules/webrtc-adapter/src/js/firefox/getusermedia.js
function shimGetUserMedia$1(window$1, browserDetails) {
	const navigator$1 = window$1 && window$1.navigator;
	const MediaStreamTrack = window$1 && window$1.MediaStreamTrack;
	navigator$1.getUserMedia = function(constraints, onSuccess, onError) {
		deprecated("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia");
		navigator$1.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
	};
	if (!(browserDetails.version > 55 && "autoGainControl" in navigator$1.mediaDevices.getSupportedConstraints())) {
		const remap = function(obj, a$1, b) {
			if (a$1 in obj && !(b in obj)) {
				obj[b] = obj[a$1];
				delete obj[a$1];
			}
		};
		const nativeGetUserMedia = navigator$1.mediaDevices.getUserMedia.bind(navigator$1.mediaDevices);
		navigator$1.mediaDevices.getUserMedia = function(c$1) {
			if (typeof c$1 === "object" && typeof c$1.audio === "object") {
				c$1 = JSON.parse(JSON.stringify(c$1));
				remap(c$1.audio, "autoGainControl", "mozAutoGainControl");
				remap(c$1.audio, "noiseSuppression", "mozNoiseSuppression");
			}
			return nativeGetUserMedia(c$1);
		};
		if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {
			const nativeGetSettings = MediaStreamTrack.prototype.getSettings;
			MediaStreamTrack.prototype.getSettings = function() {
				const obj = nativeGetSettings.apply(this, arguments);
				remap(obj, "mozAutoGainControl", "autoGainControl");
				remap(obj, "mozNoiseSuppression", "noiseSuppression");
				return obj;
			};
		}
		if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {
			const nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;
			MediaStreamTrack.prototype.applyConstraints = function(c$1) {
				if (this.kind === "audio" && typeof c$1 === "object") {
					c$1 = JSON.parse(JSON.stringify(c$1));
					remap(c$1, "autoGainControl", "mozAutoGainControl");
					remap(c$1, "noiseSuppression", "mozNoiseSuppression");
				}
				return nativeApplyConstraints.apply(this, [c$1]);
			};
		}
	}
}

//#endregion
//#region node_modules/webrtc-adapter/src/js/firefox/getdisplaymedia.js
function shimGetDisplayMedia(window$1, preferredMediaSource) {
	if (window$1.navigator.mediaDevices && "getDisplayMedia" in window$1.navigator.mediaDevices) return;
	if (!window$1.navigator.mediaDevices) return;
	window$1.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {
		if (!(constraints && constraints.video)) {
			const err = new DOMException("getDisplayMedia without video constraints is undefined");
			err.name = "NotFoundError";
			err.code = 8;
			return Promise.reject(err);
		}
		if (constraints.video === true) constraints.video = { mediaSource: preferredMediaSource };
		else constraints.video.mediaSource = preferredMediaSource;
		return window$1.navigator.mediaDevices.getUserMedia(constraints);
	};
}

//#endregion
//#region node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js
var firefox_shim_exports = /* @__PURE__ */ __export({
	shimAddTransceiver: () => shimAddTransceiver,
	shimCreateAnswer: () => shimCreateAnswer,
	shimCreateOffer: () => shimCreateOffer,
	shimGetDisplayMedia: () => shimGetDisplayMedia,
	shimGetParameters: () => shimGetParameters,
	shimGetUserMedia: () => shimGetUserMedia$1,
	shimOnTrack: () => shimOnTrack,
	shimPeerConnection: () => shimPeerConnection,
	shimRTCDataChannel: () => shimRTCDataChannel,
	shimReceiverGetStats: () => shimReceiverGetStats,
	shimRemoveStream: () => shimRemoveStream,
	shimSenderGetStats: () => shimSenderGetStats
});
function shimOnTrack(window$1) {
	if (typeof window$1 === "object" && window$1.RTCTrackEvent && "receiver" in window$1.RTCTrackEvent.prototype && !("transceiver" in window$1.RTCTrackEvent.prototype)) Object.defineProperty(window$1.RTCTrackEvent.prototype, "transceiver", { get() {
		return { receiver: this.receiver };
	} });
}
function shimPeerConnection(window$1, browserDetails) {
	if (typeof window$1 !== "object" || !(window$1.RTCPeerConnection || window$1.mozRTCPeerConnection)) return;
	if (!window$1.RTCPeerConnection && window$1.mozRTCPeerConnection) window$1.RTCPeerConnection = window$1.mozRTCPeerConnection;
	if (browserDetails.version < 53) [
		"setLocalDescription",
		"setRemoteDescription",
		"addIceCandidate"
	].forEach(function(method) {
		const nativeMethod = window$1.RTCPeerConnection.prototype[method];
		const methodObj = { [method]() {
			arguments[0] = new (method === "addIceCandidate" ? window$1.RTCIceCandidate : window$1.RTCSessionDescription)(arguments[0]);
			return nativeMethod.apply(this, arguments);
		} };
		window$1.RTCPeerConnection.prototype[method] = methodObj[method];
	});
	const modernStatsTypes = {
		inboundrtp: "inbound-rtp",
		outboundrtp: "outbound-rtp",
		candidatepair: "candidate-pair",
		localcandidate: "local-candidate",
		remotecandidate: "remote-candidate"
	};
	const nativeGetStats = window$1.RTCPeerConnection.prototype.getStats;
	window$1.RTCPeerConnection.prototype.getStats = function getStats() {
		const [selector, onSucc, onErr] = arguments;
		return nativeGetStats.apply(this, [selector || null]).then((stats) => {
			if (browserDetails.version < 53 && !onSucc) try {
				stats.forEach((stat) => {
					stat.type = modernStatsTypes[stat.type] || stat.type;
				});
			} catch (e$1) {
				if (e$1.name !== "TypeError") throw e$1;
				stats.forEach((stat, i$1) => {
					stats.set(i$1, Object.assign({}, stat, { type: modernStatsTypes[stat.type] || stat.type }));
				});
			}
			return stats;
		}).then(onSucc, onErr);
	};
}
function shimSenderGetStats(window$1) {
	if (!(typeof window$1 === "object" && window$1.RTCPeerConnection && window$1.RTCRtpSender)) return;
	if (window$1.RTCRtpSender && "getStats" in window$1.RTCRtpSender.prototype) return;
	const origGetSenders = window$1.RTCPeerConnection.prototype.getSenders;
	if (origGetSenders) window$1.RTCPeerConnection.prototype.getSenders = function getSenders() {
		const senders = origGetSenders.apply(this, []);
		senders.forEach((sender) => sender._pc = this);
		return senders;
	};
	const origAddTrack = window$1.RTCPeerConnection.prototype.addTrack;
	if (origAddTrack) window$1.RTCPeerConnection.prototype.addTrack = function addTrack() {
		const sender = origAddTrack.apply(this, arguments);
		sender._pc = this;
		return sender;
	};
	window$1.RTCRtpSender.prototype.getStats = function getStats() {
		return this.track ? this._pc.getStats(this.track) : Promise.resolve(/* @__PURE__ */ new Map());
	};
}
function shimReceiverGetStats(window$1) {
	if (!(typeof window$1 === "object" && window$1.RTCPeerConnection && window$1.RTCRtpSender)) return;
	if (window$1.RTCRtpSender && "getStats" in window$1.RTCRtpReceiver.prototype) return;
	const origGetReceivers = window$1.RTCPeerConnection.prototype.getReceivers;
	if (origGetReceivers) window$1.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
		const receivers = origGetReceivers.apply(this, []);
		receivers.forEach((receiver) => receiver._pc = this);
		return receivers;
	};
	wrapPeerConnectionEvent(window$1, "track", (e$1) => {
		e$1.receiver._pc = e$1.srcElement;
		return e$1;
	});
	window$1.RTCRtpReceiver.prototype.getStats = function getStats() {
		return this._pc.getStats(this.track);
	};
}
function shimRemoveStream(window$1) {
	if (!window$1.RTCPeerConnection || "removeStream" in window$1.RTCPeerConnection.prototype) return;
	window$1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
		deprecated("removeStream", "removeTrack");
		this.getSenders().forEach((sender) => {
			if (sender.track && stream.getTracks().includes(sender.track)) this.removeTrack(sender);
		});
	};
}
function shimRTCDataChannel(window$1) {
	if (window$1.DataChannel && !window$1.RTCDataChannel) window$1.RTCDataChannel = window$1.DataChannel;
}
function shimAddTransceiver(window$1) {
	if (!(typeof window$1 === "object" && window$1.RTCPeerConnection)) return;
	const origAddTransceiver = window$1.RTCPeerConnection.prototype.addTransceiver;
	if (origAddTransceiver) window$1.RTCPeerConnection.prototype.addTransceiver = function addTransceiver() {
		this.setParametersPromises = [];
		let sendEncodings = arguments[1] && arguments[1].sendEncodings;
		if (sendEncodings === void 0) sendEncodings = [];
		sendEncodings = [...sendEncodings];
		const shouldPerformCheck = sendEncodings.length > 0;
		if (shouldPerformCheck) sendEncodings.forEach((encodingParam) => {
			if ("rid" in encodingParam) {
				if (!/^[a-z0-9]{0,16}$/i.test(encodingParam.rid)) throw new TypeError("Invalid RID value provided.");
			}
			if ("scaleResolutionDownBy" in encodingParam) {
				if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1)) throw new RangeError("scale_resolution_down_by must be >= 1.0");
			}
			if ("maxFramerate" in encodingParam) {
				if (!(parseFloat(encodingParam.maxFramerate) >= 0)) throw new RangeError("max_framerate must be >= 0.0");
			}
		});
		const transceiver = origAddTransceiver.apply(this, arguments);
		if (shouldPerformCheck) {
			const { sender } = transceiver;
			const params = sender.getParameters();
			if (!("encodings" in params) || params.encodings.length === 1 && Object.keys(params.encodings[0]).length === 0) {
				params.encodings = sendEncodings;
				sender.sendEncodings = sendEncodings;
				this.setParametersPromises.push(sender.setParameters(params).then(() => {
					delete sender.sendEncodings;
				}).catch(() => {
					delete sender.sendEncodings;
				}));
			}
		}
		return transceiver;
	};
}
function shimGetParameters(window$1) {
	if (!(typeof window$1 === "object" && window$1.RTCRtpSender)) return;
	const origGetParameters = window$1.RTCRtpSender.prototype.getParameters;
	if (origGetParameters) window$1.RTCRtpSender.prototype.getParameters = function getParameters() {
		const params = origGetParameters.apply(this, arguments);
		if (!("encodings" in params)) params.encodings = [].concat(this.sendEncodings || [{}]);
		return params;
	};
}
function shimCreateOffer(window$1) {
	if (!(typeof window$1 === "object" && window$1.RTCPeerConnection)) return;
	const origCreateOffer = window$1.RTCPeerConnection.prototype.createOffer;
	window$1.RTCPeerConnection.prototype.createOffer = function createOffer() {
		if (this.setParametersPromises && this.setParametersPromises.length) return Promise.all(this.setParametersPromises).then(() => {
			return origCreateOffer.apply(this, arguments);
		}).finally(() => {
			this.setParametersPromises = [];
		});
		return origCreateOffer.apply(this, arguments);
	};
}
function shimCreateAnswer(window$1) {
	if (!(typeof window$1 === "object" && window$1.RTCPeerConnection)) return;
	const origCreateAnswer = window$1.RTCPeerConnection.prototype.createAnswer;
	window$1.RTCPeerConnection.prototype.createAnswer = function createAnswer() {
		if (this.setParametersPromises && this.setParametersPromises.length) return Promise.all(this.setParametersPromises).then(() => {
			return origCreateAnswer.apply(this, arguments);
		}).finally(() => {
			this.setParametersPromises = [];
		});
		return origCreateAnswer.apply(this, arguments);
	};
}

//#endregion
//#region node_modules/webrtc-adapter/src/js/safari/safari_shim.js
var safari_shim_exports = /* @__PURE__ */ __export({
	shimAudioContext: () => shimAudioContext,
	shimCallbacksAPI: () => shimCallbacksAPI,
	shimConstraints: () => shimConstraints,
	shimCreateOfferLegacy: () => shimCreateOfferLegacy,
	shimGetUserMedia: () => shimGetUserMedia,
	shimLocalStreamsAPI: () => shimLocalStreamsAPI,
	shimRTCIceServerUrls: () => shimRTCIceServerUrls,
	shimRemoteStreamsAPI: () => shimRemoteStreamsAPI,
	shimTrackEventTransceiver: () => shimTrackEventTransceiver
});
function shimLocalStreamsAPI(window$1) {
	if (typeof window$1 !== "object" || !window$1.RTCPeerConnection) return;
	if (!("getLocalStreams" in window$1.RTCPeerConnection.prototype)) window$1.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
		if (!this._localStreams) this._localStreams = [];
		return this._localStreams;
	};
	if (!("addStream" in window$1.RTCPeerConnection.prototype)) {
		const _addTrack = window$1.RTCPeerConnection.prototype.addTrack;
		window$1.RTCPeerConnection.prototype.addStream = function addStream(stream) {
			if (!this._localStreams) this._localStreams = [];
			if (!this._localStreams.includes(stream)) this._localStreams.push(stream);
			stream.getAudioTracks().forEach((track) => _addTrack.call(this, track, stream));
			stream.getVideoTracks().forEach((track) => _addTrack.call(this, track, stream));
		};
		window$1.RTCPeerConnection.prototype.addTrack = function addTrack(track, ...streams) {
			if (streams) streams.forEach((stream) => {
				if (!this._localStreams) this._localStreams = [stream];
				else if (!this._localStreams.includes(stream)) this._localStreams.push(stream);
			});
			return _addTrack.apply(this, arguments);
		};
	}
	if (!("removeStream" in window$1.RTCPeerConnection.prototype)) window$1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
		if (!this._localStreams) this._localStreams = [];
		const index = this._localStreams.indexOf(stream);
		if (index === -1) return;
		this._localStreams.splice(index, 1);
		const tracks = stream.getTracks();
		this.getSenders().forEach((sender) => {
			if (tracks.includes(sender.track)) this.removeTrack(sender);
		});
	};
}
function shimRemoteStreamsAPI(window$1) {
	if (typeof window$1 !== "object" || !window$1.RTCPeerConnection) return;
	if (!("getRemoteStreams" in window$1.RTCPeerConnection.prototype)) window$1.RTCPeerConnection.prototype.getRemoteStreams = function getRemoteStreams() {
		return this._remoteStreams ? this._remoteStreams : [];
	};
	if (!("onaddstream" in window$1.RTCPeerConnection.prototype)) {
		Object.defineProperty(window$1.RTCPeerConnection.prototype, "onaddstream", {
			get() {
				return this._onaddstream;
			},
			set(f$1) {
				if (this._onaddstream) {
					this.removeEventListener("addstream", this._onaddstream);
					this.removeEventListener("track", this._onaddstreampoly);
				}
				this.addEventListener("addstream", this._onaddstream = f$1);
				this.addEventListener("track", this._onaddstreampoly = (e$1) => {
					e$1.streams.forEach((stream) => {
						if (!this._remoteStreams) this._remoteStreams = [];
						if (this._remoteStreams.includes(stream)) return;
						this._remoteStreams.push(stream);
						const event = new Event("addstream");
						event.stream = stream;
						this.dispatchEvent(event);
					});
				});
			}
		});
		const origSetRemoteDescription = window$1.RTCPeerConnection.prototype.setRemoteDescription;
		window$1.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
			const pc = this;
			if (!this._onaddstreampoly) this.addEventListener("track", this._onaddstreampoly = function(e$1) {
				e$1.streams.forEach((stream) => {
					if (!pc._remoteStreams) pc._remoteStreams = [];
					if (pc._remoteStreams.indexOf(stream) >= 0) return;
					pc._remoteStreams.push(stream);
					const event = new Event("addstream");
					event.stream = stream;
					pc.dispatchEvent(event);
				});
			});
			return origSetRemoteDescription.apply(pc, arguments);
		};
	}
}
function shimCallbacksAPI(window$1) {
	if (typeof window$1 !== "object" || !window$1.RTCPeerConnection) return;
	const prototype = window$1.RTCPeerConnection.prototype;
	const origCreateOffer = prototype.createOffer;
	const origCreateAnswer = prototype.createAnswer;
	const setLocalDescription = prototype.setLocalDescription;
	const setRemoteDescription = prototype.setRemoteDescription;
	const addIceCandidate = prototype.addIceCandidate;
	prototype.createOffer = function createOffer(successCallback, failureCallback) {
		const options = arguments.length >= 2 ? arguments[2] : arguments[0];
		const promise = origCreateOffer.apply(this, [options]);
		if (!failureCallback) return promise;
		promise.then(successCallback, failureCallback);
		return Promise.resolve();
	};
	prototype.createAnswer = function createAnswer(successCallback, failureCallback) {
		const options = arguments.length >= 2 ? arguments[2] : arguments[0];
		const promise = origCreateAnswer.apply(this, [options]);
		if (!failureCallback) return promise;
		promise.then(successCallback, failureCallback);
		return Promise.resolve();
	};
	let withCallback = function(description, successCallback, failureCallback) {
		const promise = setLocalDescription.apply(this, [description]);
		if (!failureCallback) return promise;
		promise.then(successCallback, failureCallback);
		return Promise.resolve();
	};
	prototype.setLocalDescription = withCallback;
	withCallback = function(description, successCallback, failureCallback) {
		const promise = setRemoteDescription.apply(this, [description]);
		if (!failureCallback) return promise;
		promise.then(successCallback, failureCallback);
		return Promise.resolve();
	};
	prototype.setRemoteDescription = withCallback;
	withCallback = function(candidate, successCallback, failureCallback) {
		const promise = addIceCandidate.apply(this, [candidate]);
		if (!failureCallback) return promise;
		promise.then(successCallback, failureCallback);
		return Promise.resolve();
	};
	prototype.addIceCandidate = withCallback;
}
function shimGetUserMedia(window$1) {
	const navigator$1 = window$1 && window$1.navigator;
	if (navigator$1.mediaDevices && navigator$1.mediaDevices.getUserMedia) {
		const mediaDevices = navigator$1.mediaDevices;
		const _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);
		navigator$1.mediaDevices.getUserMedia = (constraints) => {
			return _getUserMedia(shimConstraints(constraints));
		};
	}
	if (!navigator$1.getUserMedia && navigator$1.mediaDevices && navigator$1.mediaDevices.getUserMedia) navigator$1.getUserMedia = function getUserMedia(constraints, cb, errcb) {
		navigator$1.mediaDevices.getUserMedia(constraints).then(cb, errcb);
	}.bind(navigator$1);
}
function shimConstraints(constraints) {
	if (constraints && constraints.video !== void 0) return Object.assign({}, constraints, { video: compactObject(constraints.video) });
	return constraints;
}
function shimRTCIceServerUrls(window$1) {
	if (!window$1.RTCPeerConnection) return;
	const OrigPeerConnection = window$1.RTCPeerConnection;
	window$1.RTCPeerConnection = function RTCPeerConnection(pcConfig, pcConstraints) {
		if (pcConfig && pcConfig.iceServers) {
			const newIceServers = [];
			for (let i$1 = 0; i$1 < pcConfig.iceServers.length; i$1++) {
				let server = pcConfig.iceServers[i$1];
				if (server.urls === void 0 && server.url) {
					deprecated("RTCIceServer.url", "RTCIceServer.urls");
					server = JSON.parse(JSON.stringify(server));
					server.urls = server.url;
					delete server.url;
					newIceServers.push(server);
				} else newIceServers.push(pcConfig.iceServers[i$1]);
			}
			pcConfig.iceServers = newIceServers;
		}
		return new OrigPeerConnection(pcConfig, pcConstraints);
	};
	window$1.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
	if ("generateCertificate" in OrigPeerConnection) Object.defineProperty(window$1.RTCPeerConnection, "generateCertificate", { get() {
		return OrigPeerConnection.generateCertificate;
	} });
}
function shimTrackEventTransceiver(window$1) {
	if (typeof window$1 === "object" && window$1.RTCTrackEvent && "receiver" in window$1.RTCTrackEvent.prototype && !("transceiver" in window$1.RTCTrackEvent.prototype)) Object.defineProperty(window$1.RTCTrackEvent.prototype, "transceiver", { get() {
		return { receiver: this.receiver };
	} });
}
function shimCreateOfferLegacy(window$1) {
	const origCreateOffer = window$1.RTCPeerConnection.prototype.createOffer;
	window$1.RTCPeerConnection.prototype.createOffer = function createOffer(offerOptions) {
		if (offerOptions) {
			if (typeof offerOptions.offerToReceiveAudio !== "undefined") offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;
			const audioTransceiver = this.getTransceivers().find((transceiver) => transceiver.receiver.track.kind === "audio");
			if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {
				if (audioTransceiver.direction === "sendrecv") if (audioTransceiver.setDirection) audioTransceiver.setDirection("sendonly");
				else audioTransceiver.direction = "sendonly";
				else if (audioTransceiver.direction === "recvonly") if (audioTransceiver.setDirection) audioTransceiver.setDirection("inactive");
				else audioTransceiver.direction = "inactive";
			} else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) this.addTransceiver("audio", { direction: "recvonly" });
			if (typeof offerOptions.offerToReceiveVideo !== "undefined") offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;
			const videoTransceiver = this.getTransceivers().find((transceiver) => transceiver.receiver.track.kind === "video");
			if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {
				if (videoTransceiver.direction === "sendrecv") if (videoTransceiver.setDirection) videoTransceiver.setDirection("sendonly");
				else videoTransceiver.direction = "sendonly";
				else if (videoTransceiver.direction === "recvonly") if (videoTransceiver.setDirection) videoTransceiver.setDirection("inactive");
				else videoTransceiver.direction = "inactive";
			} else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) this.addTransceiver("video", { direction: "recvonly" });
		}
		return origCreateOffer.apply(this, arguments);
	};
}
function shimAudioContext(window$1) {
	if (typeof window$1 !== "object" || window$1.AudioContext) return;
	window$1.AudioContext = window$1.webkitAudioContext;
}

//#endregion
//#region node_modules/sdp/sdp.js
var require_sdp = /* @__PURE__ */ __commonJS({ "node_modules/sdp/sdp.js": ((exports, module) => {
	var SDPUtils$1 = {};
	SDPUtils$1.generateIdentifier = function() {
		return Math.random().toString(36).substring(2, 12);
	};
	SDPUtils$1.localCName = SDPUtils$1.generateIdentifier();
	SDPUtils$1.splitLines = function(blob) {
		return blob.trim().split("\n").map((line) => line.trim());
	};
	SDPUtils$1.splitSections = function(blob) {
		return blob.split("\nm=").map((part, index) => (index > 0 ? "m=" + part : part).trim() + "\r\n");
	};
	SDPUtils$1.getDescription = function(blob) {
		const sections = SDPUtils$1.splitSections(blob);
		return sections && sections[0];
	};
	SDPUtils$1.getMediaSections = function(blob) {
		const sections = SDPUtils$1.splitSections(blob);
		sections.shift();
		return sections;
	};
	SDPUtils$1.matchPrefix = function(blob, prefix) {
		return SDPUtils$1.splitLines(blob).filter((line) => line.indexOf(prefix) === 0);
	};
	SDPUtils$1.parseCandidate = function(line) {
		let parts;
		if (line.indexOf("a=candidate:") === 0) parts = line.substring(12).split(" ");
		else parts = line.substring(10).split(" ");
		const candidate = {
			foundation: parts[0],
			component: {
				1: "rtp",
				2: "rtcp"
			}[parts[1]] || parts[1],
			protocol: parts[2].toLowerCase(),
			priority: parseInt(parts[3], 10),
			ip: parts[4],
			address: parts[4],
			port: parseInt(parts[5], 10),
			type: parts[7]
		};
		for (let i$1 = 8; i$1 < parts.length; i$1 += 2) switch (parts[i$1]) {
			case "raddr":
				candidate.relatedAddress = parts[i$1 + 1];
				break;
			case "rport":
				candidate.relatedPort = parseInt(parts[i$1 + 1], 10);
				break;
			case "tcptype":
				candidate.tcpType = parts[i$1 + 1];
				break;
			case "ufrag":
				candidate.ufrag = parts[i$1 + 1];
				candidate.usernameFragment = parts[i$1 + 1];
				break;
			default:
				if (candidate[parts[i$1]] === void 0) candidate[parts[i$1]] = parts[i$1 + 1];
				break;
		}
		return candidate;
	};
	SDPUtils$1.writeCandidate = function(candidate) {
		const sdp = [];
		sdp.push(candidate.foundation);
		const component = candidate.component;
		if (component === "rtp") sdp.push(1);
		else if (component === "rtcp") sdp.push(2);
		else sdp.push(component);
		sdp.push(candidate.protocol.toUpperCase());
		sdp.push(candidate.priority);
		sdp.push(candidate.address || candidate.ip);
		sdp.push(candidate.port);
		const type = candidate.type;
		sdp.push("typ");
		sdp.push(type);
		if (type !== "host" && candidate.relatedAddress && candidate.relatedPort) {
			sdp.push("raddr");
			sdp.push(candidate.relatedAddress);
			sdp.push("rport");
			sdp.push(candidate.relatedPort);
		}
		if (candidate.tcpType && candidate.protocol.toLowerCase() === "tcp") {
			sdp.push("tcptype");
			sdp.push(candidate.tcpType);
		}
		if (candidate.usernameFragment || candidate.ufrag) {
			sdp.push("ufrag");
			sdp.push(candidate.usernameFragment || candidate.ufrag);
		}
		return "candidate:" + sdp.join(" ");
	};
	SDPUtils$1.parseIceOptions = function(line) {
		return line.substring(14).split(" ");
	};
	SDPUtils$1.parseRtpMap = function(line) {
		let parts = line.substring(9).split(" ");
		const parsed = { payloadType: parseInt(parts.shift(), 10) };
		parts = parts[0].split("/");
		parsed.name = parts[0];
		parsed.clockRate = parseInt(parts[1], 10);
		parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
		parsed.numChannels = parsed.channels;
		return parsed;
	};
	SDPUtils$1.writeRtpMap = function(codec) {
		let pt = codec.payloadType;
		if (codec.preferredPayloadType !== void 0) pt = codec.preferredPayloadType;
		const channels = codec.channels || codec.numChannels || 1;
		return "a=rtpmap:" + pt + " " + codec.name + "/" + codec.clockRate + (channels !== 1 ? "/" + channels : "") + "\r\n";
	};
	SDPUtils$1.parseExtmap = function(line) {
		const parts = line.substring(9).split(" ");
		return {
			id: parseInt(parts[0], 10),
			direction: parts[0].indexOf("/") > 0 ? parts[0].split("/")[1] : "sendrecv",
			uri: parts[1],
			attributes: parts.slice(2).join(" ")
		};
	};
	SDPUtils$1.writeExtmap = function(headerExtension) {
		return "a=extmap:" + (headerExtension.id || headerExtension.preferredId) + (headerExtension.direction && headerExtension.direction !== "sendrecv" ? "/" + headerExtension.direction : "") + " " + headerExtension.uri + (headerExtension.attributes ? " " + headerExtension.attributes : "") + "\r\n";
	};
	SDPUtils$1.parseFmtp = function(line) {
		const parsed = {};
		let kv;
		const parts = line.substring(line.indexOf(" ") + 1).split(";");
		for (let j = 0; j < parts.length; j++) {
			kv = parts[j].trim().split("=");
			parsed[kv[0].trim()] = kv[1];
		}
		return parsed;
	};
	SDPUtils$1.writeFmtp = function(codec) {
		let line = "";
		let pt = codec.payloadType;
		if (codec.preferredPayloadType !== void 0) pt = codec.preferredPayloadType;
		if (codec.parameters && Object.keys(codec.parameters).length) {
			const params = [];
			Object.keys(codec.parameters).forEach((param) => {
				if (codec.parameters[param] !== void 0) params.push(param + "=" + codec.parameters[param]);
				else params.push(param);
			});
			line += "a=fmtp:" + pt + " " + params.join(";") + "\r\n";
		}
		return line;
	};
	SDPUtils$1.parseRtcpFb = function(line) {
		const parts = line.substring(line.indexOf(" ") + 1).split(" ");
		return {
			type: parts.shift(),
			parameter: parts.join(" ")
		};
	};
	SDPUtils$1.writeRtcpFb = function(codec) {
		let lines = "";
		let pt = codec.payloadType;
		if (codec.preferredPayloadType !== void 0) pt = codec.preferredPayloadType;
		if (codec.rtcpFeedback && codec.rtcpFeedback.length) codec.rtcpFeedback.forEach((fb) => {
			lines += "a=rtcp-fb:" + pt + " " + fb.type + (fb.parameter && fb.parameter.length ? " " + fb.parameter : "") + "\r\n";
		});
		return lines;
	};
	SDPUtils$1.parseSsrcMedia = function(line) {
		const sp = line.indexOf(" ");
		const parts = { ssrc: parseInt(line.substring(7, sp), 10) };
		const colon = line.indexOf(":", sp);
		if (colon > -1) {
			parts.attribute = line.substring(sp + 1, colon);
			parts.value = line.substring(colon + 1);
		} else parts.attribute = line.substring(sp + 1);
		return parts;
	};
	SDPUtils$1.parseSsrcGroup = function(line) {
		const parts = line.substring(13).split(" ");
		return {
			semantics: parts.shift(),
			ssrcs: parts.map((ssrc) => parseInt(ssrc, 10))
		};
	};
	SDPUtils$1.getMid = function(mediaSection) {
		const mid = SDPUtils$1.matchPrefix(mediaSection, "a=mid:")[0];
		if (mid) return mid.substring(6);
	};
	SDPUtils$1.parseFingerprint = function(line) {
		const parts = line.substring(14).split(" ");
		return {
			algorithm: parts[0].toLowerCase(),
			value: parts[1].toUpperCase()
		};
	};
	SDPUtils$1.getDtlsParameters = function(mediaSection, sessionpart) {
		return {
			role: "auto",
			fingerprints: SDPUtils$1.matchPrefix(mediaSection + sessionpart, "a=fingerprint:").map(SDPUtils$1.parseFingerprint)
		};
	};
	SDPUtils$1.writeDtlsParameters = function(params, setupType) {
		let sdp = "a=setup:" + setupType + "\r\n";
		params.fingerprints.forEach((fp) => {
			sdp += "a=fingerprint:" + fp.algorithm + " " + fp.value + "\r\n";
		});
		return sdp;
	};
	SDPUtils$1.parseCryptoLine = function(line) {
		const parts = line.substring(9).split(" ");
		return {
			tag: parseInt(parts[0], 10),
			cryptoSuite: parts[1],
			keyParams: parts[2],
			sessionParams: parts.slice(3)
		};
	};
	SDPUtils$1.writeCryptoLine = function(parameters) {
		return "a=crypto:" + parameters.tag + " " + parameters.cryptoSuite + " " + (typeof parameters.keyParams === "object" ? SDPUtils$1.writeCryptoKeyParams(parameters.keyParams) : parameters.keyParams) + (parameters.sessionParams ? " " + parameters.sessionParams.join(" ") : "") + "\r\n";
	};
	SDPUtils$1.parseCryptoKeyParams = function(keyParams) {
		if (keyParams.indexOf("inline:") !== 0) return null;
		const parts = keyParams.substring(7).split("|");
		return {
			keyMethod: "inline",
			keySalt: parts[0],
			lifeTime: parts[1],
			mkiValue: parts[2] ? parts[2].split(":")[0] : void 0,
			mkiLength: parts[2] ? parts[2].split(":")[1] : void 0
		};
	};
	SDPUtils$1.writeCryptoKeyParams = function(keyParams) {
		return keyParams.keyMethod + ":" + keyParams.keySalt + (keyParams.lifeTime ? "|" + keyParams.lifeTime : "") + (keyParams.mkiValue && keyParams.mkiLength ? "|" + keyParams.mkiValue + ":" + keyParams.mkiLength : "");
	};
	SDPUtils$1.getCryptoParameters = function(mediaSection, sessionpart) {
		return SDPUtils$1.matchPrefix(mediaSection + sessionpart, "a=crypto:").map(SDPUtils$1.parseCryptoLine);
	};
	SDPUtils$1.getIceParameters = function(mediaSection, sessionpart) {
		const ufrag = SDPUtils$1.matchPrefix(mediaSection + sessionpart, "a=ice-ufrag:")[0];
		const pwd = SDPUtils$1.matchPrefix(mediaSection + sessionpart, "a=ice-pwd:")[0];
		if (!(ufrag && pwd)) return null;
		return {
			usernameFragment: ufrag.substring(12),
			password: pwd.substring(10)
		};
	};
	SDPUtils$1.writeIceParameters = function(params) {
		let sdp = "a=ice-ufrag:" + params.usernameFragment + "\r\na=ice-pwd:" + params.password + "\r\n";
		if (params.iceLite) sdp += "a=ice-lite\r\n";
		return sdp;
	};
	SDPUtils$1.parseRtpParameters = function(mediaSection) {
		const description = {
			codecs: [],
			headerExtensions: [],
			fecMechanisms: [],
			rtcp: []
		};
		const mline = SDPUtils$1.splitLines(mediaSection)[0].split(" ");
		description.profile = mline[2];
		for (let i$1 = 3; i$1 < mline.length; i$1++) {
			const pt = mline[i$1];
			const rtpmapline = SDPUtils$1.matchPrefix(mediaSection, "a=rtpmap:" + pt + " ")[0];
			if (rtpmapline) {
				const codec = SDPUtils$1.parseRtpMap(rtpmapline);
				const fmtps = SDPUtils$1.matchPrefix(mediaSection, "a=fmtp:" + pt + " ");
				codec.parameters = fmtps.length ? SDPUtils$1.parseFmtp(fmtps[0]) : {};
				codec.rtcpFeedback = SDPUtils$1.matchPrefix(mediaSection, "a=rtcp-fb:" + pt + " ").map(SDPUtils$1.parseRtcpFb);
				description.codecs.push(codec);
				switch (codec.name.toUpperCase()) {
					case "RED":
					case "ULPFEC":
						description.fecMechanisms.push(codec.name.toUpperCase());
						break;
					default: break;
				}
			}
		}
		SDPUtils$1.matchPrefix(mediaSection, "a=extmap:").forEach((line) => {
			description.headerExtensions.push(SDPUtils$1.parseExtmap(line));
		});
		const wildcardRtcpFb = SDPUtils$1.matchPrefix(mediaSection, "a=rtcp-fb:* ").map(SDPUtils$1.parseRtcpFb);
		description.codecs.forEach((codec) => {
			wildcardRtcpFb.forEach((fb) => {
				if (!codec.rtcpFeedback.find((existingFeedback) => {
					return existingFeedback.type === fb.type && existingFeedback.parameter === fb.parameter;
				})) codec.rtcpFeedback.push(fb);
			});
		});
		return description;
	};
	SDPUtils$1.writeRtpDescription = function(kind, caps) {
		let sdp = "";
		sdp += "m=" + kind + " ";
		sdp += caps.codecs.length > 0 ? "9" : "0";
		sdp += " " + (caps.profile || "UDP/TLS/RTP/SAVPF") + " ";
		sdp += caps.codecs.map((codec) => {
			if (codec.preferredPayloadType !== void 0) return codec.preferredPayloadType;
			return codec.payloadType;
		}).join(" ") + "\r\n";
		sdp += "c=IN IP4 0.0.0.0\r\n";
		sdp += "a=rtcp:9 IN IP4 0.0.0.0\r\n";
		caps.codecs.forEach((codec) => {
			sdp += SDPUtils$1.writeRtpMap(codec);
			sdp += SDPUtils$1.writeFmtp(codec);
			sdp += SDPUtils$1.writeRtcpFb(codec);
		});
		let maxptime = 0;
		caps.codecs.forEach((codec) => {
			if (codec.maxptime > maxptime) maxptime = codec.maxptime;
		});
		if (maxptime > 0) sdp += "a=maxptime:" + maxptime + "\r\n";
		if (caps.headerExtensions) caps.headerExtensions.forEach((extension) => {
			sdp += SDPUtils$1.writeExtmap(extension);
		});
		return sdp;
	};
	SDPUtils$1.parseRtpEncodingParameters = function(mediaSection) {
		const encodingParameters = [];
		const description = SDPUtils$1.parseRtpParameters(mediaSection);
		const hasRed = description.fecMechanisms.indexOf("RED") !== -1;
		const hasUlpfec = description.fecMechanisms.indexOf("ULPFEC") !== -1;
		const ssrcs = SDPUtils$1.matchPrefix(mediaSection, "a=ssrc:").map((line) => SDPUtils$1.parseSsrcMedia(line)).filter((parts) => parts.attribute === "cname");
		const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
		let secondarySsrc;
		const flows = SDPUtils$1.matchPrefix(mediaSection, "a=ssrc-group:FID").map((line) => {
			return line.substring(17).split(" ").map((part) => parseInt(part, 10));
		});
		if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) secondarySsrc = flows[0][1];
		description.codecs.forEach((codec) => {
			if (codec.name.toUpperCase() === "RTX" && codec.parameters.apt) {
				let encParam = {
					ssrc: primarySsrc,
					codecPayloadType: parseInt(codec.parameters.apt, 10)
				};
				if (primarySsrc && secondarySsrc) encParam.rtx = { ssrc: secondarySsrc };
				encodingParameters.push(encParam);
				if (hasRed) {
					encParam = JSON.parse(JSON.stringify(encParam));
					encParam.fec = {
						ssrc: primarySsrc,
						mechanism: hasUlpfec ? "red+ulpfec" : "red"
					};
					encodingParameters.push(encParam);
				}
			}
		});
		if (encodingParameters.length === 0 && primarySsrc) encodingParameters.push({ ssrc: primarySsrc });
		let bandwidth = SDPUtils$1.matchPrefix(mediaSection, "b=");
		if (bandwidth.length) {
			if (bandwidth[0].indexOf("b=TIAS:") === 0) bandwidth = parseInt(bandwidth[0].substring(7), 10);
			else if (bandwidth[0].indexOf("b=AS:") === 0) bandwidth = parseInt(bandwidth[0].substring(5), 10) * 1e3 * .95 - 2e3 * 8;
			else bandwidth = void 0;
			encodingParameters.forEach((params) => {
				params.maxBitrate = bandwidth;
			});
		}
		return encodingParameters;
	};
	SDPUtils$1.parseRtcpParameters = function(mediaSection) {
		const rtcpParameters = {};
		const remoteSsrc = SDPUtils$1.matchPrefix(mediaSection, "a=ssrc:").map((line) => SDPUtils$1.parseSsrcMedia(line)).filter((obj) => obj.attribute === "cname")[0];
		if (remoteSsrc) {
			rtcpParameters.cname = remoteSsrc.value;
			rtcpParameters.ssrc = remoteSsrc.ssrc;
		}
		const rsize = SDPUtils$1.matchPrefix(mediaSection, "a=rtcp-rsize");
		rtcpParameters.reducedSize = rsize.length > 0;
		rtcpParameters.compound = rsize.length === 0;
		rtcpParameters.mux = SDPUtils$1.matchPrefix(mediaSection, "a=rtcp-mux").length > 0;
		return rtcpParameters;
	};
	SDPUtils$1.writeRtcpParameters = function(rtcpParameters) {
		let sdp = "";
		if (rtcpParameters.reducedSize) sdp += "a=rtcp-rsize\r\n";
		if (rtcpParameters.mux) sdp += "a=rtcp-mux\r\n";
		if (rtcpParameters.ssrc !== void 0 && rtcpParameters.cname) sdp += "a=ssrc:" + rtcpParameters.ssrc + " cname:" + rtcpParameters.cname + "\r\n";
		return sdp;
	};
	SDPUtils$1.parseMsid = function(mediaSection) {
		let parts;
		const spec = SDPUtils$1.matchPrefix(mediaSection, "a=msid:");
		if (spec.length === 1) {
			parts = spec[0].substring(7).split(" ");
			return {
				stream: parts[0],
				track: parts[1]
			};
		}
		const planB = SDPUtils$1.matchPrefix(mediaSection, "a=ssrc:").map((line) => SDPUtils$1.parseSsrcMedia(line)).filter((msidParts) => msidParts.attribute === "msid");
		if (planB.length > 0) {
			parts = planB[0].value.split(" ");
			return {
				stream: parts[0],
				track: parts[1]
			};
		}
	};
	SDPUtils$1.parseSctpDescription = function(mediaSection) {
		const mline = SDPUtils$1.parseMLine(mediaSection);
		const maxSizeLine = SDPUtils$1.matchPrefix(mediaSection, "a=max-message-size:");
		let maxMessageSize;
		if (maxSizeLine.length > 0) maxMessageSize = parseInt(maxSizeLine[0].substring(19), 10);
		if (isNaN(maxMessageSize)) maxMessageSize = 65536;
		const sctpPort = SDPUtils$1.matchPrefix(mediaSection, "a=sctp-port:");
		if (sctpPort.length > 0) return {
			port: parseInt(sctpPort[0].substring(12), 10),
			protocol: mline.fmt,
			maxMessageSize
		};
		const sctpMapLines = SDPUtils$1.matchPrefix(mediaSection, "a=sctpmap:");
		if (sctpMapLines.length > 0) {
			const parts = sctpMapLines[0].substring(10).split(" ");
			return {
				port: parseInt(parts[0], 10),
				protocol: parts[1],
				maxMessageSize
			};
		}
	};
	SDPUtils$1.writeSctpDescription = function(media, sctp) {
		let output = [];
		if (media.protocol !== "DTLS/SCTP") output = [
			"m=" + media.kind + " 9 " + media.protocol + " " + sctp.protocol + "\r\n",
			"c=IN IP4 0.0.0.0\r\n",
			"a=sctp-port:" + sctp.port + "\r\n"
		];
		else output = [
			"m=" + media.kind + " 9 " + media.protocol + " " + sctp.port + "\r\n",
			"c=IN IP4 0.0.0.0\r\n",
			"a=sctpmap:" + sctp.port + " " + sctp.protocol + " 65535\r\n"
		];
		if (sctp.maxMessageSize !== void 0) output.push("a=max-message-size:" + sctp.maxMessageSize + "\r\n");
		return output.join("");
	};
	SDPUtils$1.generateSessionId = function() {
		return Math.random().toString().substr(2, 22);
	};
	SDPUtils$1.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {
		let sessionId;
		const version = sessVer !== void 0 ? sessVer : 2;
		if (sessId) sessionId = sessId;
		else sessionId = SDPUtils$1.generateSessionId();
		return "v=0\r\no=" + (sessUser || "thisisadapterortc") + " " + sessionId + " " + version + " IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n";
	};
	SDPUtils$1.getDirection = function(mediaSection, sessionpart) {
		const lines = SDPUtils$1.splitLines(mediaSection);
		for (let i$1 = 0; i$1 < lines.length; i$1++) switch (lines[i$1]) {
			case "a=sendrecv":
			case "a=sendonly":
			case "a=recvonly":
			case "a=inactive": return lines[i$1].substring(2);
			default:
		}
		if (sessionpart) return SDPUtils$1.getDirection(sessionpart);
		return "sendrecv";
	};
	SDPUtils$1.getKind = function(mediaSection) {
		return SDPUtils$1.splitLines(mediaSection)[0].split(" ")[0].substring(2);
	};
	SDPUtils$1.isRejected = function(mediaSection) {
		return mediaSection.split(" ", 2)[1] === "0";
	};
	SDPUtils$1.parseMLine = function(mediaSection) {
		const parts = SDPUtils$1.splitLines(mediaSection)[0].substring(2).split(" ");
		return {
			kind: parts[0],
			port: parseInt(parts[1], 10),
			protocol: parts[2],
			fmt: parts.slice(3).join(" ")
		};
	};
	SDPUtils$1.parseOLine = function(mediaSection) {
		const parts = SDPUtils$1.matchPrefix(mediaSection, "o=")[0].substring(2).split(" ");
		return {
			username: parts[0],
			sessionId: parts[1],
			sessionVersion: parseInt(parts[2], 10),
			netType: parts[3],
			addressType: parts[4],
			address: parts[5]
		};
	};
	SDPUtils$1.isValidSDP = function(blob) {
		if (typeof blob !== "string" || blob.length === 0) return false;
		const lines = SDPUtils$1.splitLines(blob);
		for (let i$1 = 0; i$1 < lines.length; i$1++) if (lines[i$1].length < 2 || lines[i$1].charAt(1) !== "=") return false;
		return true;
	};
	if (typeof module === "object") module.exports = SDPUtils$1;
}) });

//#endregion
//#region node_modules/webrtc-adapter/src/js/common_shim.js
var common_shim_exports = /* @__PURE__ */ __export({
	removeExtmapAllowMixed: () => removeExtmapAllowMixed,
	shimAddIceCandidateNullOrEmpty: () => shimAddIceCandidateNullOrEmpty,
	shimConnectionState: () => shimConnectionState,
	shimMaxMessageSize: () => shimMaxMessageSize,
	shimParameterlessSetLocalDescription: () => shimParameterlessSetLocalDescription,
	shimRTCIceCandidate: () => shimRTCIceCandidate,
	shimRTCIceCandidateRelayProtocol: () => shimRTCIceCandidateRelayProtocol,
	shimSendThrowTypeError: () => shimSendThrowTypeError
});
var import_sdp$1 = /* @__PURE__ */ __toESM(require_sdp());
function shimRTCIceCandidate(window$1) {
	if (!window$1.RTCIceCandidate || window$1.RTCIceCandidate && "foundation" in window$1.RTCIceCandidate.prototype) return;
	const NativeRTCIceCandidate = window$1.RTCIceCandidate;
	window$1.RTCIceCandidate = function RTCIceCandidate(args) {
		if (typeof args === "object" && args.candidate && args.candidate.indexOf("a=") === 0) {
			args = JSON.parse(JSON.stringify(args));
			args.candidate = args.candidate.substring(2);
		}
		if (args.candidate && args.candidate.length) {
			const nativeCandidate = new NativeRTCIceCandidate(args);
			const parsedCandidate = import_sdp$1.default.parseCandidate(args.candidate);
			for (const key in parsedCandidate) if (!(key in nativeCandidate)) Object.defineProperty(nativeCandidate, key, { value: parsedCandidate[key] });
			nativeCandidate.toJSON = function toJSON() {
				return {
					candidate: nativeCandidate.candidate,
					sdpMid: nativeCandidate.sdpMid,
					sdpMLineIndex: nativeCandidate.sdpMLineIndex,
					usernameFragment: nativeCandidate.usernameFragment
				};
			};
			return nativeCandidate;
		}
		return new NativeRTCIceCandidate(args);
	};
	window$1.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;
	wrapPeerConnectionEvent(window$1, "icecandidate", (e$1) => {
		if (e$1.candidate) Object.defineProperty(e$1, "candidate", {
			value: new window$1.RTCIceCandidate(e$1.candidate),
			writable: "false"
		});
		return e$1;
	});
}
function shimRTCIceCandidateRelayProtocol(window$1) {
	if (!window$1.RTCIceCandidate || window$1.RTCIceCandidate && "relayProtocol" in window$1.RTCIceCandidate.prototype) return;
	wrapPeerConnectionEvent(window$1, "icecandidate", (e$1) => {
		if (e$1.candidate) {
			const parsedCandidate = import_sdp$1.default.parseCandidate(e$1.candidate.candidate);
			if (parsedCandidate.type === "relay") e$1.candidate.relayProtocol = {
				0: "tls",
				1: "tcp",
				2: "udp"
			}[parsedCandidate.priority >> 24];
		}
		return e$1;
	});
}
function shimMaxMessageSize(window$1, browserDetails) {
	if (!window$1.RTCPeerConnection) return;
	if (!("sctp" in window$1.RTCPeerConnection.prototype)) Object.defineProperty(window$1.RTCPeerConnection.prototype, "sctp", { get() {
		return typeof this._sctp === "undefined" ? null : this._sctp;
	} });
	const sctpInDescription = function(description) {
		if (!description || !description.sdp) return false;
		const sections = import_sdp$1.default.splitSections(description.sdp);
		sections.shift();
		return sections.some((mediaSection) => {
			const mLine = import_sdp$1.default.parseMLine(mediaSection);
			return mLine && mLine.kind === "application" && mLine.protocol.indexOf("SCTP") !== -1;
		});
	};
	const getRemoteFirefoxVersion = function(description) {
		const match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
		if (match === null || match.length < 2) return -1;
		const version = parseInt(match[1], 10);
		return version !== version ? -1 : version;
	};
	const getCanSendMaxMessageSize = function(remoteIsFirefox) {
		let canSendMaxMessageSize = 65536;
		if (browserDetails.browser === "firefox") if (browserDetails.version < 57) if (remoteIsFirefox === -1) canSendMaxMessageSize = 16384;
		else canSendMaxMessageSize = 2147483637;
		else if (browserDetails.version < 60) canSendMaxMessageSize = browserDetails.version === 57 ? 65535 : 65536;
		else canSendMaxMessageSize = 2147483637;
		return canSendMaxMessageSize;
	};
	const getMaxMessageSize = function(description, remoteIsFirefox) {
		let maxMessageSize = 65536;
		if (browserDetails.browser === "firefox" && browserDetails.version === 57) maxMessageSize = 65535;
		const match = import_sdp$1.default.matchPrefix(description.sdp, "a=max-message-size:");
		if (match.length > 0) maxMessageSize = parseInt(match[0].substring(19), 10);
		else if (browserDetails.browser === "firefox" && remoteIsFirefox !== -1) maxMessageSize = 2147483637;
		return maxMessageSize;
	};
	const origSetRemoteDescription = window$1.RTCPeerConnection.prototype.setRemoteDescription;
	window$1.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
		this._sctp = null;
		if (browserDetails.browser === "chrome" && browserDetails.version >= 76) {
			const { sdpSemantics } = this.getConfiguration();
			if (sdpSemantics === "plan-b") Object.defineProperty(this, "sctp", {
				get() {
					return typeof this._sctp === "undefined" ? null : this._sctp;
				},
				enumerable: true,
				configurable: true
			});
		}
		if (sctpInDescription(arguments[0])) {
			const isFirefox = getRemoteFirefoxVersion(arguments[0]);
			const canSendMMS = getCanSendMaxMessageSize(isFirefox);
			const remoteMMS = getMaxMessageSize(arguments[0], isFirefox);
			let maxMessageSize;
			if (canSendMMS === 0 && remoteMMS === 0) maxMessageSize = Number.POSITIVE_INFINITY;
			else if (canSendMMS === 0 || remoteMMS === 0) maxMessageSize = Math.max(canSendMMS, remoteMMS);
			else maxMessageSize = Math.min(canSendMMS, remoteMMS);
			const sctp = {};
			Object.defineProperty(sctp, "maxMessageSize", { get() {
				return maxMessageSize;
			} });
			this._sctp = sctp;
		}
		return origSetRemoteDescription.apply(this, arguments);
	};
}
function shimSendThrowTypeError(window$1) {
	if (!(window$1.RTCPeerConnection && "createDataChannel" in window$1.RTCPeerConnection.prototype)) return;
	function wrapDcSend(dc, pc) {
		const origDataChannelSend = dc.send;
		dc.send = function send() {
			const data = arguments[0];
			const length = data.length || data.size || data.byteLength;
			if (dc.readyState === "open" && pc.sctp && length > pc.sctp.maxMessageSize) throw new TypeError("Message too large (can send a maximum of " + pc.sctp.maxMessageSize + " bytes)");
			return origDataChannelSend.apply(dc, arguments);
		};
	}
	const origCreateDataChannel = window$1.RTCPeerConnection.prototype.createDataChannel;
	window$1.RTCPeerConnection.prototype.createDataChannel = function createDataChannel() {
		const dataChannel = origCreateDataChannel.apply(this, arguments);
		wrapDcSend(dataChannel, this);
		return dataChannel;
	};
	wrapPeerConnectionEvent(window$1, "datachannel", (e$1) => {
		wrapDcSend(e$1.channel, e$1.target);
		return e$1;
	});
}
function shimConnectionState(window$1) {
	if (!window$1.RTCPeerConnection || "connectionState" in window$1.RTCPeerConnection.prototype) return;
	const proto = window$1.RTCPeerConnection.prototype;
	Object.defineProperty(proto, "connectionState", {
		get() {
			return {
				completed: "connected",
				checking: "connecting"
			}[this.iceConnectionState] || this.iceConnectionState;
		},
		enumerable: true,
		configurable: true
	});
	Object.defineProperty(proto, "onconnectionstatechange", {
		get() {
			return this._onconnectionstatechange || null;
		},
		set(cb) {
			if (this._onconnectionstatechange) {
				this.removeEventListener("connectionstatechange", this._onconnectionstatechange);
				delete this._onconnectionstatechange;
			}
			if (cb) this.addEventListener("connectionstatechange", this._onconnectionstatechange = cb);
		},
		enumerable: true,
		configurable: true
	});
	["setLocalDescription", "setRemoteDescription"].forEach((method) => {
		const origMethod = proto[method];
		proto[method] = function() {
			if (!this._connectionstatechangepoly) {
				this._connectionstatechangepoly = (e$1) => {
					const pc = e$1.target;
					if (pc._lastConnectionState !== pc.connectionState) {
						pc._lastConnectionState = pc.connectionState;
						const newEvent = new Event("connectionstatechange", e$1);
						pc.dispatchEvent(newEvent);
					}
					return e$1;
				};
				this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly);
			}
			return origMethod.apply(this, arguments);
		};
	});
}
function removeExtmapAllowMixed(window$1, browserDetails) {
	if (!window$1.RTCPeerConnection) return;
	if (browserDetails.browser === "chrome" && browserDetails.version >= 71) return;
	if (browserDetails.browser === "safari" && browserDetails._safariVersion >= 13.1) return;
	const nativeSRD = window$1.RTCPeerConnection.prototype.setRemoteDescription;
	window$1.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(desc) {
		if (desc && desc.sdp && desc.sdp.indexOf("\na=extmap-allow-mixed") !== -1) {
			const sdp = desc.sdp.split("\n").filter((line) => {
				return line.trim() !== "a=extmap-allow-mixed";
			}).join("\n");
			if (window$1.RTCSessionDescription && desc instanceof window$1.RTCSessionDescription) arguments[0] = new window$1.RTCSessionDescription({
				type: desc.type,
				sdp
			});
			else desc.sdp = sdp;
		}
		return nativeSRD.apply(this, arguments);
	};
}
function shimAddIceCandidateNullOrEmpty(window$1, browserDetails) {
	if (!(window$1.RTCPeerConnection && window$1.RTCPeerConnection.prototype)) return;
	const nativeAddIceCandidate = window$1.RTCPeerConnection.prototype.addIceCandidate;
	if (!nativeAddIceCandidate || nativeAddIceCandidate.length === 0) return;
	window$1.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {
		if (!arguments[0]) {
			if (arguments[1]) arguments[1].apply(null);
			return Promise.resolve();
		}
		if ((browserDetails.browser === "chrome" && browserDetails.version < 78 || browserDetails.browser === "firefox" && browserDetails.version < 68 || browserDetails.browser === "safari") && arguments[0] && arguments[0].candidate === "") return Promise.resolve();
		return nativeAddIceCandidate.apply(this, arguments);
	};
}
function shimParameterlessSetLocalDescription(window$1, browserDetails) {
	if (!(window$1.RTCPeerConnection && window$1.RTCPeerConnection.prototype)) return;
	const nativeSetLocalDescription = window$1.RTCPeerConnection.prototype.setLocalDescription;
	if (!nativeSetLocalDescription || nativeSetLocalDescription.length === 0) return;
	window$1.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {
		let desc = arguments[0] || {};
		if (typeof desc !== "object" || desc.type && desc.sdp) return nativeSetLocalDescription.apply(this, arguments);
		desc = {
			type: desc.type,
			sdp: desc.sdp
		};
		if (!desc.type) switch (this.signalingState) {
			case "stable":
			case "have-local-offer":
			case "have-remote-pranswer":
				desc.type = "offer";
				break;
			default:
				desc.type = "answer";
				break;
		}
		if (desc.sdp || desc.type !== "offer" && desc.type !== "answer") return nativeSetLocalDescription.apply(this, [desc]);
		return (desc.type === "offer" ? this.createOffer : this.createAnswer).apply(this).then((d$1) => nativeSetLocalDescription.apply(this, [d$1]));
	};
}

//#endregion
//#region node_modules/webrtc-adapter/src/js/adapter_factory.js
var import_sdp = /* @__PURE__ */ __toESM(require_sdp());
function adapterFactory({ window: window$1 } = {}, options = {
	shimChrome: true,
	shimFirefox: true,
	shimSafari: true
}) {
	const logging$1 = log;
	const browserDetails = detectBrowser(window$1);
	const adapter$1 = {
		browserDetails,
		commonShim: common_shim_exports,
		extractVersion,
		disableLog,
		disableWarnings,
		sdp: import_sdp
	};
	switch (browserDetails.browser) {
		case "chrome":
			if (!chrome_shim_exports || !shimPeerConnection$1 || !options.shimChrome) {
				logging$1("Chrome shim is not included in this adapter release.");
				return adapter$1;
			}
			if (browserDetails.version === null) {
				logging$1("Chrome shim can not determine version, not shimming.");
				return adapter$1;
			}
			logging$1("adapter.js shimming chrome.");
			adapter$1.browserShim = chrome_shim_exports;
			shimAddIceCandidateNullOrEmpty(window$1, browserDetails);
			shimParameterlessSetLocalDescription(window$1, browserDetails);
			shimGetUserMedia$2(window$1, browserDetails);
			shimMediaStream(window$1, browserDetails);
			shimPeerConnection$1(window$1, browserDetails);
			shimOnTrack$1(window$1, browserDetails);
			shimAddTrackRemoveTrack(window$1, browserDetails);
			shimGetSendersWithDtmf(window$1, browserDetails);
			shimSenderReceiverGetStats(window$1, browserDetails);
			fixNegotiationNeeded(window$1, browserDetails);
			shimRTCIceCandidate(window$1, browserDetails);
			shimRTCIceCandidateRelayProtocol(window$1, browserDetails);
			shimConnectionState(window$1, browserDetails);
			shimMaxMessageSize(window$1, browserDetails);
			shimSendThrowTypeError(window$1, browserDetails);
			removeExtmapAllowMixed(window$1, browserDetails);
			break;
		case "firefox":
			if (!firefox_shim_exports || !shimPeerConnection || !options.shimFirefox) {
				logging$1("Firefox shim is not included in this adapter release.");
				return adapter$1;
			}
			logging$1("adapter.js shimming firefox.");
			adapter$1.browserShim = firefox_shim_exports;
			shimAddIceCandidateNullOrEmpty(window$1, browserDetails);
			shimParameterlessSetLocalDescription(window$1, browserDetails);
			shimGetUserMedia$1(window$1, browserDetails);
			shimPeerConnection(window$1, browserDetails);
			shimOnTrack(window$1, browserDetails);
			shimRemoveStream(window$1, browserDetails);
			shimSenderGetStats(window$1, browserDetails);
			shimReceiverGetStats(window$1, browserDetails);
			shimRTCDataChannel(window$1, browserDetails);
			shimAddTransceiver(window$1, browserDetails);
			shimGetParameters(window$1, browserDetails);
			shimCreateOffer(window$1, browserDetails);
			shimCreateAnswer(window$1, browserDetails);
			shimRTCIceCandidate(window$1, browserDetails);
			shimConnectionState(window$1, browserDetails);
			shimMaxMessageSize(window$1, browserDetails);
			shimSendThrowTypeError(window$1, browserDetails);
			break;
		case "safari":
			if (!safari_shim_exports || !options.shimSafari) {
				logging$1("Safari shim is not included in this adapter release.");
				return adapter$1;
			}
			logging$1("adapter.js shimming safari.");
			adapter$1.browserShim = safari_shim_exports;
			shimAddIceCandidateNullOrEmpty(window$1, browserDetails);
			shimParameterlessSetLocalDescription(window$1, browserDetails);
			shimRTCIceServerUrls(window$1, browserDetails);
			shimCreateOfferLegacy(window$1, browserDetails);
			shimCallbacksAPI(window$1, browserDetails);
			shimLocalStreamsAPI(window$1, browserDetails);
			shimRemoteStreamsAPI(window$1, browserDetails);
			shimTrackEventTransceiver(window$1, browserDetails);
			shimGetUserMedia(window$1, browserDetails);
			shimAudioContext(window$1, browserDetails);
			shimRTCIceCandidate(window$1, browserDetails);
			shimRTCIceCandidateRelayProtocol(window$1, browserDetails);
			shimMaxMessageSize(window$1, browserDetails);
			shimSendThrowTypeError(window$1, browserDetails);
			removeExtmapAllowMixed(window$1, browserDetails);
			break;
		default:
			logging$1("Unsupported browser!");
			break;
	}
	return adapter$1;
}

//#endregion
//#region node_modules/webrtc-adapter/src/js/adapter_core.js
var adapter = adapterFactory({ window: typeof window === "undefined" ? void 0 : window });

//#endregion
//#region node_modules/@yudiel/react-qr-scanner/dist/index.esm.mjs
var B = {
	finder: !0,
	torch: !0,
	tracker: void 0,
	onOff: !1,
	zoom: !1
}, r = {
	facingMode: "environment",
	width: {
		min: 640,
		ideal: 720,
		max: 1920
	},
	height: {
		min: 640,
		ideal: 720,
		max: 1080
	}
}, s = {
	width: "100%",
	height: "100%",
	position: "relative",
	display: "flex",
	alignItems: "center",
	justifyContent: "center",
	overflow: "hidden",
	aspectRatio: "1/1"
}, C = {
	width: "100%",
	height: "100%",
	objectFit: "cover",
	overflow: "hidden"
};
function c(A, o$1) {
	for (const g$1 of A) {
		const [A$1, ...i$1] = g$1.cornerPoints;
		o$1.lineWidth = 2, o$1.strokeStyle = "yellow", o$1.beginPath(), o$1.moveTo(A$1.x, A$1.y);
		for (const { x: A$2, y: g$2 } of i$1) o$1.lineTo(A$2, g$2);
		o$1.lineTo(A$1.x, A$1.y), o$1.closePath(), o$1.stroke();
	}
}
function E(A, o$1) {
	for (const g$1 of A) {
		const { boundingBox: { x: A$1, y: i$1, width: t$1, height: e$1 } } = g$1;
		o$1.lineWidth = 2, o$1.strokeStyle = "yellow", o$1.strokeRect(A$1, i$1, t$1, e$1);
	}
}
function h(A, o$1) {
	A.forEach((A$1) => {
		const { boundingBox: g$1, rawValue: i$1 } = A$1, t$1 = g$1.x + g$1.width / 2, e$1 = g$1.y + g$1.height / 2, w$1 = Math.max(12, 50 * g$1.width / o$1.canvas.width), n$1 = w$1;
		let a$1;
		o$1.font = `${w$1}px sans-serif`, o$1.textAlign = "left";
		try {
			a$1 = JSON.stringify(JSON.parse(i$1), null, 2);
		} catch {
			a$1 = i$1;
		}
		const B$1 = a$1.split("\n"), r$1 = Math.max(...B$1.map((A$2) => o$1.measureText(A$2).width)), s$1 = B$1.length * n$1, C$1 = t$1 - r$1 / 2 - 10, c$1 = e$1 - s$1 / 2 - 10, E$1 = r$1 + 20, h$1 = s$1 + 10;
		o$1.beginPath(), o$1.moveTo(C$1 + 8, c$1), o$1.lineTo(C$1 + E$1 - 8, c$1), o$1.quadraticCurveTo(C$1 + E$1, c$1, C$1 + E$1, c$1 + 8), o$1.lineTo(C$1 + E$1, c$1 + h$1 - 8), o$1.quadraticCurveTo(C$1 + E$1, c$1 + h$1, C$1 + E$1 - 8, c$1 + h$1), o$1.lineTo(C$1 + 8, c$1 + h$1), o$1.quadraticCurveTo(C$1, c$1 + h$1, C$1, c$1 + h$1 - 8), o$1.lineTo(C$1, c$1 + 8), o$1.quadraticCurveTo(C$1, c$1, C$1 + 8, c$1), o$1.closePath(), o$1.fillStyle = "rgba(255, 255, 0, 0.9)", o$1.fill(), B$1.forEach((A$2, g$2) => {
			const i$2 = e$1 + g$2 * n$1 - (B$1.length - 1) * n$1 / 2;
			let w$2 = t$1 - r$1 / 2, a$2 = 0;
			const s$2 = [...A$2.matchAll(/"([^"]+)":/g)], C$2 = [...A$2.matchAll(/:\s*("[^"]*"|\d+|true|false|null)/g)];
			s$2.forEach((g$3, t$2) => {
				const e$2 = g$3[0].replace(":", ""), n$2 = A$2.substring(a$2, g$3.index);
				if (o$1.fillStyle = "black", o$1.fillText(n$2, w$2, i$2), w$2 += o$1.measureText(n$2).width, o$1.fillStyle = "blue", o$1.fillText(e$2, w$2, i$2), w$2 += o$1.measureText(e$2).width, a$2 = g$3.index + e$2.length, o$1.fillStyle = "black", o$1.fillText(": ", w$2, i$2), w$2 += o$1.measureText(": ").width, t$2 < C$2.length) {
					const g$4 = C$2[t$2], e$3 = A$2.substring(a$2, g$4.index);
					o$1.fillStyle = "black", o$1.fillText(e$3, w$2, i$2), w$2 += o$1.measureText(e$3).width;
					const n$3 = g$4[0].match(/:\s*(.*)/)?.[1] ?? "";
					o$1.fillStyle = "green", o$1.fillText(n$3, w$2, i$2), w$2 += o$1.measureText(n$3).width, a$2 = g$4.index + g$4[0].length;
				}
			}), o$1.fillStyle = "black";
			const c$2 = A$2.substring(a$2);
			o$1.fillText(c$2, w$2, i$2);
		});
	});
}
var q = (A) => A instanceof Date, M = (A) => null == A;
var l = (A) => "object" == typeof A;
var I = (A) => !M(A) && !Array.isArray(A) && l(A) && !q(A), G = (A) => M(A) || !l(A);
function Y(A, o$1) {
	if (G(A) || G(o$1)) return A === o$1;
	if (q(A) && q(o$1)) return A.getTime() === o$1.getTime();
	const g$1 = A, i$1 = o$1, t$1 = Object.keys(g$1), e$1 = Object.keys(i$1);
	if (t$1.length !== e$1.length) return !1;
	for (const A$1 of t$1) {
		const o$2 = g$1[A$1];
		if (!e$1.includes(A$1)) return !1;
		if ("ref" !== A$1) {
			const g$2 = i$1[A$1];
			if (q(o$2) && q(g$2) || I(o$2) && I(g$2) || Array.isArray(o$2) && Array.isArray(g$2) ? !Y(o$2, g$2) : o$2 !== g$2) return !1;
		}
	}
	return !0;
}
function D(A) {
	const { onClick: i$1, disabled: t$1, className: e$1 } = A, w$1 = {
		cursor: t$1 ? "default" : "pointer",
		stroke: t$1 ? "grey" : "yellow",
		strokeLineJoin: "round",
		strokeLineCap: "round",
		strokeWidth: 1.5,
		...A.style
	};
	return (0, import_jsx_runtime.jsxs)("svg", {
		onClick: t$1 ? void 0 : i$1,
		className: e$1,
		style: w$1,
		width: "28px",
		height: "28px",
		viewBox: "0 0 24 24",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		children: [(0, import_jsx_runtime.jsx)("title", { children: "Camera Off" }), (0, import_jsx_runtime.jsx)("path", { d: "M3 3L6.00007 6.00007M21 21L19.8455 19.8221M9.74194 4.06811C9.83646 4.04279 9.93334 4.02428 10.0319 4.01299C10.1453 4 10.2683 4 10.5141 4H13.5327C13.7786 4 13.9015 4 14.015 4.01299C14.6068 4.08078 15.1375 4.40882 15.4628 4.90782C15.5252 5.00345 15.5802 5.11345 15.6901 5.33333C15.7451 5.44329 15.7726 5.49827 15.8037 5.54609C15.9664 5.79559 16.2318 5.95961 16.5277 5.9935C16.5844 6 16.6459 6 16.7688 6H17.8234C18.9435 6 19.5036 6 19.9314 6.21799C20.3077 6.40973 20.6137 6.71569 20.8055 7.09202C21.0234 7.51984 21.0234 8.0799 21.0234 9.2V15.3496M19.8455 19.8221C19.4278 20 18.8702 20 17.8234 20H6.22344C5.10333 20 4.54328 20 4.11546 19.782C3.73913 19.5903 3.43317 19.2843 3.24142 18.908C3.02344 18.4802 3.02344 17.9201 3.02344 16.8V9.2C3.02344 8.0799 3.02344 7.51984 3.24142 7.09202C3.43317 6.71569 3.73913 6.40973 4.11546 6.21799C4.51385 6.015 5.0269 6.00103 6.00007 6.00007M19.8455 19.8221L14.5619 14.5619M14.5619 14.5619C14.0349 15.4243 13.0847 16 12 16C10.3431 16 9 14.6569 9 13C9 11.9153 9.57566 10.9651 10.4381 10.4381M14.5619 14.5619L10.4381 10.4381M10.4381 10.4381L6.00007 6.00007" })]
	});
}
function F(A) {
	const { onClick: i$1, disabled: t$1, className: e$1 } = A, w$1 = {
		cursor: t$1 ? "default" : "pointer",
		stroke: t$1 ? "grey" : "yellow",
		strokeLineJoin: "round",
		strokeLineCap: "round",
		strokeWidth: 1.5,
		...A.style
	};
	return (0, import_jsx_runtime.jsxs)("svg", {
		onClick: t$1 ? void 0 : i$1,
		className: e$1,
		style: w$1,
		width: "28px",
		height: "28px",
		viewBox: "0 0 24 24",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		children: [
			(0, import_jsx_runtime.jsx)("title", { children: "Camera On" }),
			(0, import_jsx_runtime.jsx)("path", { d: "M12 16C13.6569 16 15 14.6569 15 13C15 11.3431 13.6569 10 12 10C10.3431 10 9 11.3431 9 13C9 14.6569 10.3431 16 12 16Z" }),
			(0, import_jsx_runtime.jsx)("path", { d: "M3 16.8V9.2C3 8.0799 3 7.51984 3.21799 7.09202C3.40973 6.71569 3.71569 6.40973 4.09202 6.21799C4.51984 6 5.0799 6 6.2 6H7.25464C7.37758 6 7.43905 6 7.49576 5.9935C7.79166 5.95961 8.05705 5.79559 8.21969 5.54609C8.25086 5.49827 8.27836 5.44328 8.33333 5.33333C8.44329 5.11342 8.49827 5.00346 8.56062 4.90782C8.8859 4.40882 9.41668 4.08078 10.0085 4.01299C10.1219 4 10.2448 4 10.4907 4H13.5093C13.7552 4 13.8781 4 13.9915 4.01299C14.5833 4.08078 15.1141 4.40882 15.4394 4.90782C15.5017 5.00345 15.5567 5.11345 15.6667 5.33333C15.7216 5.44329 15.7491 5.49827 15.7803 5.54609C15.943 5.79559 16.2083 5.95961 16.5042 5.9935C16.561 6 16.6224 6 16.7454 6H17.8C18.9201 6 19.4802 6 19.908 6.21799C20.2843 6.40973 20.5903 6.71569 20.782 7.09202C21 7.51984 21 8.0799 21 9.2V16.8C21 17.9201 21 18.4802 20.782 18.908C20.5903 19.2843 20.2843 19.5903 19.908 19.782C19.4802 20 18.9201 20 17.8 20H6.2C5.0799 20 4.51984 20 4.09202 19.782C3.71569 19.5903 3.40973 19.2843 3.21799 18.908C3 18.4802 3 17.9201 3 16.8Z" })
		]
	});
}
function T(A) {
	const { scanning: o$1, startScanning: i$1, stopScanning: e$1 } = A, [w$1, n$1] = (0, import_react.useState)(!1);
	function a$1() {
		n$1(!0), o$1 ? e$1() : i$1(), setTimeout(() => n$1(!1), 1e3);
	}
	return (0, import_jsx_runtime.jsx)("div", {
		style: {
			bottom: 85,
			right: 8,
			position: "absolute",
			zIndex: 2,
			cursor: w$1 ? "default" : "pointer"
		},
		children: (0, import_jsx_runtime.jsx)(o$1 ? D : F, {
			disabled: w$1,
			onClick: a$1
		})
	});
}
function m(A) {
	const { onClick: i$1, className: t$1, style: e$1 } = A;
	return (0, import_jsx_runtime.jsxs)("svg", {
		onClick: i$1,
		width: "30px",
		height: "30px",
		viewBox: "0 0 24 24",
		className: t$1,
		style: e$1,
		xmlns: "http://www.w3.org/2000/svg",
		children: [(0, import_jsx_runtime.jsx)("title", { children: "Torch Off" }), (0, import_jsx_runtime.jsx)("path", {
			strokeWidth: .2,
			stroke: "yellow",
			fill: "yellow",
			d: "M14.516 15.158l.714.714-4.595 6.14-.75-.364L12.337 13H6.978L8.22 8.861l.803.803L8.322 12h3.036l1.793 1.792-1.475 5.16zm5.984 4.05L4.793 3.5l.707-.707 3.492 3.492L10.278 2h7.972l-5.025 7h7.149l-3.71 4.957 4.543 4.543zM12.707 10l3.243 3.243L18.376 10zM9.795 7.088l2.079 2.079L16.3 3h-5.278z"
		})]
	});
}
function V(A) {
	const { onClick: i$1, className: t$1, style: e$1 } = A;
	return (0, import_jsx_runtime.jsxs)("svg", {
		onClick: i$1,
		width: "30px",
		height: "30px",
		viewBox: "0 0 24 24",
		className: t$1,
		style: e$1,
		xmlns: "http://www.w3.org/2000/svg",
		children: [(0, import_jsx_runtime.jsx)("title", { children: "Torch On" }), (0, import_jsx_runtime.jsx)("path", {
			strokeWidth: .2,
			stroke: "yellow",
			fill: "yellow",
			d: "M13.225 9l5.025-7h-7.972l-3.3 11h5.359l-2.452 8.648.75.364L20.374 9zm.438 3H8.322l2.7-9H16.3l-5.025 7h7.101l-6.7 8.953z"
		})]
	});
}
function Q(A) {
	const { status: o$1, scanning: i$1, torchToggle: t$1 } = A;
	function e$1(A$1) {
		t$1(A$1);
	}
	return i$1 && t$1 ? (0, import_jsx_runtime.jsx)("div", {
		style: {
			bottom: 35,
			right: 8,
			position: "absolute",
			zIndex: 2,
			cursor: "pointer"
		},
		children: o$1 ? (0, import_jsx_runtime.jsx)(m, { onClick: () => e$1(!1) }) : (0, import_jsx_runtime.jsx)(V, { onClick: () => e$1(!0) })
	}) : null;
}
function R(A) {
	const { onClick: i$1, className: t$1, disabled: e$1 = !1 } = A, w$1 = {
		cursor: e$1 ? "default" : "pointer",
		stroke: e$1 ? "grey" : "yellow",
		fill: e$1 ? "grey" : "yellow",
		...A.style
	};
	return (0, import_jsx_runtime.jsxs)("svg", {
		onClick: e$1 ? void 0 : i$1,
		width: "30px",
		height: "30px",
		viewBox: "0 0 24 24",
		className: t$1,
		style: w$1,
		xmlns: "http://www.w3.org/2000/svg",
		children: [(0, import_jsx_runtime.jsx)("title", { children: "Zoom In" }), (0, import_jsx_runtime.jsx)("path", {
			strokeWidth: .3,
			d: "M16.279,17.039c-1.396,1.209 -3.216,1.941 -5.206,1.941c-4.393,0 -7.96,-3.567 -7.96,-7.96c-0,-4.393 3.567,-7.96 7.96,-7.96c4.393,0 7.96,3.567 7.96,7.96c-0,2.044 -0.772,3.909 -2.04,5.319l0.165,0.165c1.194,1.194 2.388,2.388 3.583,3.582c0.455,0.456 -0.252,1.163 -0.707,0.708l-3.755,-3.755Zm1.754,-6.019c-0,-3.841 -3.119,-6.96 -6.96,-6.96c-3.842,0 -6.96,3.119 -6.96,6.96c-0,3.841 3.118,6.96 6.96,6.96c3.841,0 6.96,-3.119 6.96,-6.96Zm-7.46,0.5l-1.5,0c-0.645,0 -0.643,-1 -0,-1l1.5,0l-0,-1.5c-0,-0.645 1,-0.643 1,0l-0,1.5l1.5,0c0.645,0 0.643,1 -0,1l-1.5,0l-0,1.5c-0,0.645 -1,0.643 -1,0l-0,-1.5Z"
		})]
	});
}
function d(A) {
	const { onClick: i$1, className: t$1, disabled: e$1 = !1 } = A, w$1 = {
		cursor: e$1 ? "default" : "pointer",
		stroke: e$1 ? "grey" : "yellow",
		fill: e$1 ? "grey" : "yellow",
		...A.style
	};
	return (0, import_jsx_runtime.jsxs)("svg", {
		onClick: e$1 ? void 0 : i$1,
		width: "30px",
		height: "30px",
		viewBox: "0 0 24 24",
		className: t$1,
		style: w$1,
		xmlns: "http://www.w3.org/2000/svg",
		children: [(0, import_jsx_runtime.jsx)("title", { children: "Zoom Out" }), (0, import_jsx_runtime.jsx)("path", {
			strokeWidth: .3,
			d: "M16.279,17.039c-1.396,1.209 -3.216,1.941 -5.206,1.941c-4.393,0 -7.96,-3.567 -7.96,-7.96c-0,-4.393 3.567,-7.96 7.96,-7.96c4.393,0 7.96,3.567 7.96,7.96c-0,2.044 -0.772,3.909 -2.04,5.319l0.165,0.165c1.194,1.194 2.388,2.388 3.583,3.582c0.455,0.456 -0.252,1.163 -0.707,0.708l-3.755,-3.755Zm1.754,-6.019c-0,-3.841 -3.119,-6.96 -6.96,-6.96c-3.842,0 -6.96,3.119 -6.96,6.96c-0,3.841 3.118,6.96 6.96,6.96c3.841,0 6.96,-3.119 6.96,-6.96Zm-4.96,-0.5c0.645,0 0.643,1 -0,1l-4,0c-0.645,0 -0.643,-1 -0,-1l4,0Z"
		})]
	});
}
function N(A) {
	const { scanning: i$1, capabilities: t$1, onZoom: e$1, value: w$1 } = A;
	if (!i$1 || !e$1) return null;
	const a$1 = (t$1.max - t$1.min) / 3;
	return (0, import_jsx_runtime.jsxs)(import_react.Fragment, { children: [(0, import_jsx_runtime.jsx)("div", {
		style: {
			bottom: 130,
			right: 8,
			position: "absolute",
			zIndex: 2,
			cursor: "pointer"
		},
		children: (0, import_jsx_runtime.jsx)(d, {
			disabled: w$1 <= t$1.min,
			onClick: function() {
				e$1(Math.max(w$1 - a$1, t$1.min));
			}
		})
	}), (0, import_jsx_runtime.jsx)("div", {
		style: {
			bottom: 180,
			right: 8,
			position: "absolute",
			zIndex: 2,
			cursor: "pointer"
		},
		children: (0, import_jsx_runtime.jsx)(R, {
			disabled: w$1 >= t$1.max,
			onClick: function() {
				e$1(Math.min(w$1 + a$1, t$1.max));
			}
		})
	})] });
}
var f = {
	fullContainer: {
		width: "100%",
		height: "100%",
		position: "relative",
		display: "flex",
		alignItems: "center",
		justifyContent: "center",
		overflow: "hidden"
	},
	innerContainer: {
		width: "100%",
		height: "100%",
		display: "flex",
		alignItems: "center",
		justifyContent: "center",
		position: "relative"
	},
	overlay: {
		position: "absolute",
		top: 0,
		right: 0,
		bottom: 0,
		left: 0,
		pointerEvents: "none",
		display: "flex",
		alignItems: "center",
		justifyContent: "center"
	},
	borderBox: {
		position: "relative",
		width: "70%",
		aspectRatio: "1 / 1",
		border: "2px dashed rgba(239, 68, 68, 0.4)",
		borderRadius: "0.5rem"
	},
	cornerTopLeft: {
		position: "absolute",
		width: "15%",
		height: "15%",
		border: "4px solid #ef4444",
		top: 0,
		left: 0,
		borderBottomColor: "transparent",
		borderRightColor: "transparent",
		borderTopLeftRadius: "0.5rem"
	},
	cornerTopRight: {
		position: "absolute",
		width: "15%",
		height: "15%",
		border: "4px solid #ef4444",
		top: 0,
		right: 0,
		borderBottomColor: "transparent",
		borderLeftColor: "transparent",
		borderTopRightRadius: "0.5rem"
	},
	cornerBottomLeft: {
		position: "absolute",
		width: "15%",
		height: "15%",
		border: "4px solid #ef4444",
		bottom: 0,
		left: 0,
		borderTopColor: "transparent",
		borderRightColor: "transparent",
		borderBottomLeftRadius: "0.5rem"
	},
	cornerBottomRight: {
		position: "absolute",
		width: "15%",
		height: "15%",
		border: "4px solid #ef4444",
		bottom: 0,
		right: 0,
		borderTopColor: "transparent",
		borderLeftColor: "transparent",
		borderBottomRightRadius: "0.5rem"
	}
};
function p(A) {
	const { scanning: i$1, capabilities: t$1, onOff: e$1, torch: w$1, zoom: n$1, startScanning: a$1, stopScanning: B$1 } = A;
	return (0, import_jsx_runtime.jsx)("div", {
		style: f.fullContainer,
		children: (0, import_jsx_runtime.jsxs)("div", {
			style: f.innerContainer,
			children: [
				(0, import_jsx_runtime.jsx)("div", {
					style: f.overlay,
					children: (0, import_jsx_runtime.jsxs)("div", {
						style: f.borderBox,
						children: [
							(0, import_jsx_runtime.jsx)("div", { style: f.cornerTopLeft }),
							(0, import_jsx_runtime.jsx)("div", { style: f.cornerTopRight }),
							(0, import_jsx_runtime.jsx)("div", { style: f.cornerBottomLeft }),
							(0, import_jsx_runtime.jsx)("div", { style: f.cornerBottomRight })
						]
					})
				}),
				e$1 && (0, import_jsx_runtime.jsx)(T, {
					scanning: i$1,
					startScanning: a$1,
					stopScanning: B$1
				}),
				w$1 && t$1.torch && (0, import_jsx_runtime.jsx)(Q, {
					scanning: i$1,
					status: w$1.status,
					torchToggle: w$1.toggle
				}),
				n$1 && t$1.zoom && (0, import_jsx_runtime.jsx)(N, {
					scanning: i$1,
					capabilities: t$1.zoom,
					value: n$1.value,
					onZoom: n$1.onChange
				})
			]
		})
	});
}
function u(A) {
	if (null === A) throw new Error("Canvas should always be defined when component is mounted.");
	const o$1 = A.getContext("2d");
	if (null === o$1) throw new Error("Canvas 2D context should be non-null");
	o$1.clearRect(0, 0, A.width, A.height);
}
function k(n$1) {
	const { onScan: c$1, constraints: E$1, formats: h$1 = ["any"], paused: q$1 = !1, components: M$1, children: l$1, styles: I$1, classNames: G$1, allowMultiple: D$1, scanDelay: F$1, onError: T$1, sound: m$1 } = n$1, V$1 = (0, import_react.useRef)(null), Q$1 = (0, import_react.useRef)(null), R$1 = (0, import_react.useRef)(null), d$1 = (0, import_react.useMemo)(() => ({
		...r,
		...E$1
	}), [E$1]), N$1 = (0, import_react.useMemo)(() => ({
		...B,
		...M$1
	}), [M$1]), [f$1, k$1] = (0, import_react.useState)(!1), [y$1, K] = (0, import_react.useState)(!0), [L, J] = (0, import_react.useState)(d$1), x = function() {
		const A = (0, import_react.useRef)(Promise.resolve({
			type: "stop",
			data: {}
		})), o$1 = (0, import_react.useRef)(null), g$1 = (0, import_react.useRef)(null), [n$2, a$1] = (0, import_react.useState)({}), [B$1, r$1] = (0, import_react.useState)({}), s$1 = (0, import_react.useCallback)(async (A$1, i$1) => {
			if (!window.isSecureContext) throw new Error("camera access is only permitted in secure context. Use HTTPS or localhost rather than HTTP.");
			if (void 0 === navigator?.mediaDevices?.getUserMedia) throw new Error("this browser has no Stream API support");
			const t$1 = await navigator.mediaDevices.getUserMedia({
				audio: !1,
				video: i$1
			});
			void 0 !== A$1.srcObject ? A$1.srcObject = t$1 : void 0 !== A$1.mozSrcObject ? A$1.mozSrcObject = t$1 : window.URL.createObjectURL ? A$1.src = window.URL.createObjectURL(t$1) : window.webkitURL ? A$1.src = window.webkitURL.createObjectURL(t$1) : A$1.src = t$1.id, await Promise.race([A$1.play(), new Promise((A$2) => setTimeout(A$2, 3e3)).then(() => {
				throw new Error("Loading camera stream timed out after 3 seconds.");
			})]), await new Promise((A$2) => setTimeout(A$2, 500));
			const [e$1] = t$1.getVideoTracks();
			return r$1(e$1.getSettings()), a$1(e$1?.getCapabilities?.() ?? {}), o$1.current = t$1, g$1.current = e$1, {
				type: "start",
				data: {
					videoEl: A$1,
					stream: t$1,
					constraints: i$1
				}
			};
		}, []), C$1 = (0, import_react.useCallback)(async (A$1, i$1) => {
			A$1.src = "", A$1.srcObject = null, A$1.load();
			for (const A$2 of i$1.getTracks()) i$1.removeTrack(A$2), A$2.stop();
			return o$1.current = null, g$1.current = null, r$1({}), {
				type: "stop",
				data: {}
			};
		}, []), c$2 = (0, import_react.useCallback)(async (o$2, { constraints: g$2, restart: i$1 = !1 }) => {
			let t$1 = null;
			A.current = A.current.then((A$1) => {
				if ("start" === A$1.type) {
					const { data: { videoEl: t$2, stream: e$2, constraints: w$1 } } = A$1;
					return i$1 || o$2 !== t$2 || g$2 !== w$1 ? C$1(t$2, e$2).then(() => s$1(o$2, g$2)) : A$1;
				}
				return s$1(o$2, g$2);
			}).catch((A$1) => (t$1 = A$1, {
				type: "stop",
				data: {}
			}));
			const e$1 = await A.current;
			if (t$1) throw t$1;
			if ("stop" === e$1.type) throw new Error("Something went wrong with the camera task queue (start task).");
		}, [s$1, C$1]), E$2 = (0, import_react.useCallback)(async () => {
			if (A.current = A.current.then((A$1) => {
				if ("stop" === A$1.type) return A$1;
				const { data: { videoEl: o$2, stream: g$2 } } = A$1;
				return C$1(o$2, g$2);
			}), "start" === (await A.current).type) throw new Error("Something went wrong with the camera task queue (stop task).");
		}, [C$1]), h$2 = (0, import_react.useCallback)(async (A$1) => {
			const o$2 = g$1.current;
			if (!o$2) throw new Error("No active video track found.");
			{
				A$1.advanced?.[0].zoom && o$2.getCapabilities().torch && await o$2.applyConstraints({ advanced: [{ torch: !1 }] }), await o$2.applyConstraints(A$1);
				const g$2 = o$2.getCapabilities(), i$1 = o$2.getSettings();
				a$1(g$2), r$1(i$1);
			}
		}, []);
		return (0, import_react.useEffect)(() => () => {
			(async () => {
				await E$2();
			})();
		}, [E$2]), {
			capabilities: n$2,
			settings: B$1,
			startCamera: c$2,
			stopCamera: E$2,
			updateConstraints: h$2
		};
	}(), U = (0, import_react.useRef)(x), Z = (0, import_react.useRef)(T$1), W = (0, import_react.useRef)(N$1.tracker);
	(0, import_react.useEffect)(() => {
		U.current = x;
	}, [x]), (0, import_react.useEffect)(() => {
		Z.current = T$1;
	}, [T$1]), (0, import_react.useEffect)(() => {
		W.current = N$1.tracker;
	}, [N$1.tracker]);
	const { startScanning: b, stopScanning: O } = function(o$1) {
		const { videoElementRef: g$1, onScan: t$1, onFound: n$2, retryDelay: a$1 = 100, scanDelay: B$1 = 0, formats: r$1 = [], allowMultiple: s$1 = !1, sound: C$1 = !0 } = o$1, c$2 = (0, import_react.useRef)(new bo({ formats: r$1 })), E$2 = (0, import_react.useRef)(null), h$2 = (0, import_react.useRef)(null);
		(0, import_react.useEffect)(() => {
			c$2.current = new bo({ formats: r$1 });
		}, [r$1]), (0, import_react.useEffect)(() => {
			"undefined" != typeof window && C$1 && (E$2.current = new Audio("string" == typeof C$1 ? C$1 : "data:audio/mp3;base64,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"));
		}, [C$1]);
		const q$2 = (0, import_react.useCallback)((A) => async (o$2) => {
			if (null !== g$1.current && g$1.current.readyState > 1) {
				const { lastScan: i$1, contentBefore: e$1, lastScanHadContent: w$1 } = A;
				if (o$2 - i$1 < a$1) h$2.current = window.requestAnimationFrame(q$2(A));
				else {
					const i$2 = await c$2.current.detect(g$1.current), a$2 = i$2.some((A$1) => !e$1.includes(A$1.rawValue)), r$2 = i$2.length > 0;
					let M$2 = A.lastOnScan;
					(a$2 || s$1 && r$2 && o$2 - M$2 >= B$1) && (C$1 && E$2.current && E$2.current.paused && E$2.current.play().catch((A$1) => console.error("Error playing the sound", A$1)), M$2 = o$2, t$1(i$2)), r$2 && n$2(i$2), !r$2 && w$1 && n$2(i$2);
					const l$2 = {
						lastScan: o$2,
						lastOnScan: M$2,
						lastScanHadContent: r$2,
						contentBefore: a$2 ? i$2.map((A$1) => A$1.rawValue) : e$1
					};
					h$2.current = window.requestAnimationFrame(q$2(l$2));
				}
			}
		}, [
			g$1.current,
			t$1,
			n$2,
			a$1,
			s$1,
			B$1,
			C$1
		]);
		return {
			startScanning: (0, import_react.useCallback)(() => {
				const A = performance.now(), o$2 = {
					lastScan: A,
					lastOnScan: A,
					contentBefore: [],
					lastScanHadContent: !1
				};
				h$2.current = window.requestAnimationFrame(q$2(o$2));
			}, [q$2]),
			stopScanning: (0, import_react.useCallback)(() => {
				null !== h$2.current && (window.cancelAnimationFrame(h$2.current), h$2.current = null);
			}, [])
		};
	}({
		videoElementRef: V$1,
		onScan: c$1,
		onFound: (0, import_react.useCallback)((A) => {
			(function(A$1, o$1, g$1, i$1) {
				const t$1 = g$1;
				if (null == t$1) throw new Error("onFound handler should only be called when component is mounted. Thus tracking canvas is always defined.");
				const e$1 = o$1;
				if (null == e$1) throw new Error("onFound handler should only be called when component is mounted. Thus video element is always defined.");
				if (0 === A$1.length || void 0 === i$1) u(t$1);
				else {
					const o$2 = e$1.offsetWidth, g$2 = e$1.offsetHeight, w$1 = e$1.videoWidth, n$2 = e$1.videoHeight, a$1 = Math.max(o$2 / w$1, g$2 / n$2), B$1 = w$1 * a$1, r$1 = n$2 * a$1, s$1 = B$1 / w$1, C$1 = r$1 / n$2, c$2 = (o$2 - B$1) / 2, E$2 = (g$2 - r$1) / 2, h$2 = ({ x: A$2, y: o$3 }) => ({
						x: Math.floor(A$2 * s$1),
						y: Math.floor(o$3 * C$1)
					}), q$2 = ({ x: A$2, y: o$3 }) => ({
						x: Math.floor(A$2 + c$2),
						y: Math.floor(o$3 + E$2)
					}), M$2 = A$1.map((A$2) => {
						const { boundingBox: o$3, cornerPoints: g$3 } = A$2, { x: i$2, y: t$2 } = q$2(h$2({
							x: o$3.x,
							y: o$3.y
						})), { x: e$2, y: w$2 } = h$2({
							x: o$3.width,
							y: o$3.height
						});
						return {
							...A$2,
							cornerPoints: g$3.map((A$3) => q$2(h$2(A$3))),
							boundingBox: DOMRectReadOnly.fromRect({
								x: i$2,
								y: t$2,
								width: e$2,
								height: w$2
							})
						};
					});
					t$1.width = e$1.offsetWidth, t$1.height = e$1.offsetHeight;
					const l$2 = t$1.getContext("2d");
					if (null === l$2) throw new Error("onFound handler should only be called when component is mounted. Thus tracking canvas 2D context is always defined.");
					i$1(M$2, l$2);
				}
			})(A, V$1.current, R$1.current, W.current);
		}, []),
		formats: h$1,
		retryDelay: void 0 === N$1.tracker ? 500 : 10,
		scanDelay: F$1,
		allowMultiple: D$1,
		sound: m$1
	});
	(0, import_react.useEffect)(() => (k$1(!0), () => {
		k$1(!1);
	}), []), (0, import_react.useEffect)(() => {
		f$1 && (O(), b());
	}, [
		f$1,
		b,
		O
	]), (0, import_react.useEffect)(() => {
		if (!Y(d$1, L)) {
			const A = d$1;
			E$1?.deviceId && delete A.facingMode, J(A);
		}
	}, [
		E$1,
		d$1,
		L
	]);
	const P = (0, import_react.useMemo)(() => ({
		constraints: L,
		shouldStream: f$1 && !q$1
	}), [
		L,
		f$1,
		q$1
	]), H = (0, import_react.useCallback)(async () => {
		const A = V$1.current;
		if (null == A) throw new Error("Video should be defined when component is mounted.");
		const o$1 = Q$1.current;
		if (null == o$1) throw new Error("Canvas should be defined when component is mounted.");
		const g$1 = o$1.getContext("2d");
		if (null == g$1) throw new Error("Canvas should be defined when component is mounted.");
		if (P.shouldStream) {
			await U.current.stopCamera(), K(!1);
			try {
				await U.current.startCamera(A, P), A ? K(!0) : await U.current.stopCamera();
			} catch (A$1) {
				Z.current?.(A$1), console.error("error", A$1);
			}
		} else o$1.width = A.videoWidth, o$1.height = A.videoHeight, g$1.drawImage(A, 0, 0, A.videoWidth, A.videoHeight), await U.current.stopCamera(), K(!1);
	}, [P]);
	(0, import_react.useEffect)(() => {
		(async () => {
			await H();
		})();
	}, [H]);
	const S = (0, import_react.useMemo)(() => P.shouldStream && y$1, [P.shouldStream, y$1]);
	return (0, import_react.useEffect)(() => {
		if (S) {
			if (void 0 === Q$1.current) throw new Error("shouldScan effect should only be triggered when component is mounted. Thus pause frame canvas is defined");
			if (u(Q$1.current), void 0 === R$1.current) throw new Error("shouldScan effect should only be triggered when component is mounted. Thus tracking canvas is defined");
			u(R$1.current);
			if (null == V$1.current) throw new Error("shouldScan effect should only be triggered when component is mounted. Thus video element is defined");
			b();
		}
	}, [S, b]), (0, import_jsx_runtime.jsxs)("div", {
		style: {
			...s,
			...I$1?.container
		},
		className: G$1?.container,
		children: [
			(0, import_jsx_runtime.jsx)("video", {
				ref: V$1,
				style: {
					...C,
					...I$1?.video,
					visibility: q$1 ? "hidden" : "visible"
				},
				className: G$1?.video,
				autoPlay: !0,
				muted: !0,
				playsInline: !0
			}),
			(0, import_jsx_runtime.jsx)("canvas", {
				ref: Q$1,
				style: {
					display: q$1 ? "block" : "none",
					position: "absolute",
					width: "100%",
					height: "100%"
				}
			}),
			(0, import_jsx_runtime.jsx)("canvas", {
				ref: R$1,
				style: {
					position: "absolute",
					width: "100%",
					height: "100%"
				}
			}),
			(0, import_jsx_runtime.jsxs)("div", {
				style: {
					position: "absolute",
					width: "100%",
					height: "100%"
				},
				children: [N$1.finder && (0, import_jsx_runtime.jsx)(p, {
					scanning: y$1,
					capabilities: x.capabilities,
					onOff: N$1.onOff,
					zoom: N$1.zoom && x.settings.zoom ? {
						value: x.settings.zoom,
						onChange: async (A) => {
							const o$1 = {
								...L,
								advanced: [{ zoom: A }]
							};
							await x.updateConstraints(o$1);
						}
					} : void 0,
					torch: N$1.torch ? {
						status: x.settings.torch ?? !1,
						toggle: async (A) => {
							const o$1 = {
								...L,
								advanced: [{ torch: A }]
							};
							await x.updateConstraints(o$1);
						}
					} : void 0,
					startScanning: async () => await H(),
					stopScanning: async () => {
						await x.stopCamera(), u(R$1.current), K(!1);
					}
				}), l$1]
			})
		]
	});
}
function y() {
	const [A, o$1] = (0, import_react.useState)([]), g$1 = (0, import_react.useCallback)(async () => (await navigator.mediaDevices.enumerateDevices()).filter((A$1) => "videoinput" === A$1.kind), []);
	return (0, import_react.useEffect)(() => {
		(async () => {
			o$1(await g$1());
		})();
	}, [g$1]), A;
}

//#endregion
export { k as Scanner, E as boundingBox, h as centerText, c as outline, qe as prepareZXingModule, go as setZXingModuleOverrides, y as useDevices };
//# sourceMappingURL=@yudiel_react-qr-scanner.js.map